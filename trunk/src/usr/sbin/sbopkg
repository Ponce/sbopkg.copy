#!/bin/sh
#
# $Id$
#
# sbopkg - The SlackBuilds.org Package Browser
# Copyright 2007-2009 Chess Griffin <chess@chessgriffin.com>
#
# Redistribution and use of this script, with or without modification, is
# permitted provided that the following conditions are met:
#
# 1. Redistributions of this script must retain the above copyright notice,
# this list of conditions and the following disclaimer.
#
#  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
#  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
#  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
#  NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
#  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
#  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
#  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
#  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
#  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
#  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
#  Slackware is a registered trademark of Patrick Volkerding.
#  Linux is a registered trademark of Linus Torvalds.
#
#  Other contributors:  Bob Lounsbury, Robby Workman, Alan Hicks, Paul
#  Wisehart, slakmagik, Eric Hameleers, Michiel van Wessem, hba, Erik Hanson,
#  Antoine, ktabic, Ken Roberts, samac, Bert Babington, Murat D. Kadirov,
#  The-spiki, David Somero, LukenShiro, Drew Ames, nille, acidchild, mancha,
#  macavity, Zordrak, JoÃ£o Felipe Santos, cotterochan, necropresto, Pierre
#  Cazenave, Mauro Giachero, The-Croupier, Wade Grant, TSquaredF, and
#  alkos333.  This script would not be where it is without the help of these
#  folks.  If I left anyone out, I apologize.  Thank you!
#
#set -x

dialog_refresh_workaround() {
    # Dialog has refresh problems on some terminals (currently known are some
    # rxvt-based terminals and screen sessions), preventing correct dialogs
    # rendering.  This function enables a workaround, consisting of a
    # background task sending SIGWINCH to any new dialog instance.  Despite
    # being probably harmless on "good" terminals, this function should really
    # be called only on problematic ones.

    DIALOG_REFRESH_WORKAROUND_SBOPKG_PID=$$

    (   # The background task runs in a separate shell
        OLDDIALOGS=
        while [[ $(ps h --pid $DIALOG_REFRESH_WORKAROUND_SBOPKG_PID) ]]; do
            DIALOGS=$(pgrep -x "^dialog$")
            if [[ "$DIALOGS" != "$OLDDIALOGS" ]]; then
                [[ "$DIALOGS" ]] && kill -WINCH $DIALOGS
                OLDDIALOGS="$DIALOGS"
            fi
            sleep 0.3
        done
    ) &
}

crunch() {
    # The inspiration for this and the next function comes from the crunch()
    # in installpkg. Both take one argument.  This function reduces runs of
    # spaces to one.

    echo -e "$@" | tr -s ' '
}

crunch_fmt() {
    # This echo reduces runs of spaces to one and reformats to 78 columns

    echo -e "$@" | tr -s ' ' | fmt -78
}

config_check() {
    # Check if config file is there and if so check that it has all
    # needed variables with any value, and set them.

    local MISSING VAR

    if [[ ! -d $SBOPKG_REPOS_D ]]; then
        echo "$SCRIPT: No $SBOPKG_REPOS_D was found." 1>&2
        echo "Please correct this error and run $SCRIPT again." 1>&2
        exit 1
    fi
    if [[ ! -d $SBOPKG_RENAMES_D ]]; then
        echo "$SCRIPT: No $SBOPKG_RENAMES_D was found." 1>&2
        echo "Please correct this error and run $SCRIPT again." 1>&2
        exit 1
    fi
    if [[ ! -e $SBOPKG_CONF && ! -e $HOME/.sbopkg.conf ]]; then
        echo "$SCRIPT: No $SBOPKG_CONF or ~/.sbopkg.conf was found." 1>&2
        echo "Please create at least one of them and run $SCRIPT again." 1>&2
        exit 1
    else
        [[ -e $SBOPKG_CONF ]] && . $SBOPKG_CONF
        [[ -e $HOME/.sbopkg.conf ]] && . $HOME/.sbopkg.conf

        KEEPLOG=$(echo "$KEEPLOG" | tr "[:lower:]" "[:upper:]")
        if [[ $KEEPLOG == YES ]]; then
            KEEPLOG=1
        else
            unset KEEPLOG
        fi
        # Some configuration options are mandatory
        for VAR in REPO_ROOT LOGDIR QUEUEDIR SRCDIR SBOPKGTMP REPO_NAME \
            REPO_BRANCH KEEPLOG LOGFILE DEBUG TMP OUTPUT RSYNCFLAGS \
            WGETFLAGS DIFF DIFFOPTS SBOPKG_REPOS_D; do
            if [[ -z "${!VAR}" ]]; then
                MISSING+="$VAR "
            fi
        done
        if [[ "$MISSING" ]]; then
            cat << EOF

ERROR
$SCRIPT: Can't find a value for variable(s):
$MISSING

If you have recently upgraded sbopkg there may be
new variables in the sbopkg.conf file.  Please
merge the sbopkg.conf.new file with your existing
sbopkg.conf file.  Please see the sbopkg.conf(5)
man page for more details.

Please correct this error and run $SCRIPT again.

EOF
           exit 1
        fi
        if [[ $DEBUG -ne 0 && $DEBUG -ne 1 && $DEBUG -ne 2 ]]; then
            echo "The \$DEBUG variable must be set to 0, 1, or 2." 1>&2
            exit 1
        fi
    fi

    # Make sure there are no unexpected files in $SBOPKGTMP
    if [[ -n $(find $SBOPKGTMP -maxdepth 1 -not -name sbopkg\*) ]]; then
        cat << EOF

ERROR
$SCRIPT: Unexpected files found in working directory

$SCRIPT performs many file operations, including some 'rm -rf',
inside \$SBOPKGTMP, which is currently set to:
$SBOPKGTMP

As a safety measure to prevent user data loss due to a bad
program configuration, $SCRIPT will now exit. Please fix this
error by making sure that \$SBOPKGTMP refers to a directory
$SCRIPT can use freely, and then make sure it contains no
stale files.

If \$SBOPKGTMP is actually correct, and the only files it
contains are $SCRIPT-generated, please file a bug report.

EOF
        exit 1
    fi

    # Load the repositories data
    eval REPOSITORIES=( $(cat $SBOPKG_REPOS_D/*.repo | grep -v '#' |
        sed 's:":\\":g' | xargs echo) )

    # Check for ncurses
    [[ -x /usr/bin/tput ]] && HAS_NCURSES=1
}

ck_dir() {
    # This function displays the directory-creation message and then creates
    # the missing directory.

    local DIR=$1
    local MSG="$2"
    local ERROR=0
    local JUNK

    # Try to create the specified folder
    if [[ ! -d $DIR ]]; then
        echo
        crunch_fmt "$MSG"
        echo
        read -n1 -sep "Press any key to continue or Ctrl-C to exit."
        mkdir -p $DIR 2> /dev/null && echo "Directory created." || ERROR=1
    fi

    # Try to create a file in the specified folder
    if [[ $ERROR -eq 0 ]]; then
        (> $DIR/sbopkg-testfile 2> /dev/null && rm -f \
        $DIR/sbopkg-testfile 2> /dev/null) || ERROR=2
    fi

    case $ERROR in
        1 ) crunch_fmt "\\nWARNING:\
                \\n$SCRIPT: Unable to create $DIR.\
                \\n\\nMake sure you have enough privileges to create that\
                directory, or specify a different location in sbopkg.conf.\
                \\nSee the sbopkg.conf(5) man page for more details.\
                \\n\\nPress ENTER to continue anyway, CTRL-C to abort."
            read JUNK
            ;;
        2 ) crunch_fmt "\\nWARNING:\
                \\n$SCRIPT: Unable to create files in $DIR.\
                \\n\\nMake sure you have enough privileges to write in\
                that directory, or specify a different location in\
                sbopkg.conf.\
                \\nSee the sbopkg.conf(5) man page for more details.\
                \\n\\nPress ENTER to continue anyway, CTRL-C to abort."
            read JUNK
            ;;
    esac
}

directory_checks() {
    # Check and make sure certain sbopkg-related directories exist.
    # If not, create them.

    ck_dir $REPO_DIR \
        "Creating local repository directory $REPO_DIR for the \
            script mirror."
    ck_dir $LOGDIR \
        "Creating log directory $LOGDIR."
    ck_dir $QUEUEDIR \
        "Creating queues directory $QUEUEDIR."
    ck_dir $SRCDIR \
        "Creating local cache directory $SRCDIR to keep downloaded sources."
    ck_dir $SBOPKGTMP \
        "Creating local sbopkg TMP directory $SBOPKGTMP."
    ck_dir $TMP \
        "Creating local SBo TMP directory $TMP."
    ck_dir $OUTPUT \
        "Creating local package output directory $OUTPUT."

    # Let's catch Control-C and try to exit cleanly.  Please see the
    # comment to the control_c function, below.
    trap 'control_c' 2 14 15
}

pid_check() {
    # Set and check for pid file.
    local PIDFILE OTHERPID

    PIDFILE=/var/run/sbopkg.pid
    if [[ -e $PIDFILE ]]; then
        # When things go haywire and sbopkg crashes (this happens only on
        # development versions, of course ;-)) the PIDFILE isn't deleted and
        # triggers the error below on the following run.  Perform a basic test
        # to reduce the amount of false positives. Note that no check on the
        # file name is performed, to avoid missing true positives in the
        # (rare, but possible) cases where the user renames the sbopkg script.

        OTHERPID=$(< $PIDFILE)
        if [[ -n $(ps h --pid $OTHERPID) ]]; then
            cat << EOF

ERROR
Another instance of sbopkg appears to be running
with process id $OTHERPID.  Running more than
one instance of sbopkg is not recommended.

If this is incorrect, you can delete the lockfile
'$PIDFILE' and restart.  Exiting now.
EOF
           exit 1
        fi
    fi
    cleanup
    echo $$ > $PIDFILE
}

check_write() {
    # Check to see whether the user has write permissions on the
    # directory.

    local DIR=$1

    if [[ ! -w $DIR ]]; then
        return 1
    else
        return 0
    fi
}

check_if_repo_exists() {
    # Check to see if $REPO_DIR exists and not empty

    if [[ ! -d $REPO_DIR ]]; then
        if [[ $DIAG ]]; then
            dialog --title "ERROR" --msgbox "$(crunch "The directory \
                $REPO_DIR was not found or is empty.  Please make \
                sure your repository directory is set correctly and that you \
                have done a sync first.")"  12 30
            continue
        else
            cat << EOF

ERROR
The directory $REPO_DIR was not found
or is empty.  Please make sure your respository
directory is set correctly and that you have done
a sync first.
EOF
            cleanup
            exit 1
        fi
    fi
}

show_changelog() {
    # Show the SlackBuilds.org changelog.

    check_if_repo_exists

    cd $REPO_DIR
    if [[ ! -r ./ChangeLog.txt ]]; then
        if [[ $DIAG ]]; then
            dialog --title "ERROR" --msgbox "$(crunch "ChangeLog.txt not \
                found or not readable.  Please make sure your repository \
                directory is set correctly and that you have done a sync \
                first.")" 10 30
            return
        else
            cat << EOF

ERROR
No ChangeLog.txt found.  Please make sure your
repository directory is set correctly and that
you have done a sync first.  Exiting.
EOF
            cleanup
            exit 1
        fi
    else
        if [[ $DIAG ]]; then
            dialog --title "$REPO_DESC ChangeLog.txt" \
                --textbox ./ChangeLog.txt 0 0
        else
            $PAGER ./ChangeLog.txt
        fi
    fi
}

get_sbo_packages() {
    # Get a list of SBo packages.

    local PKGS FILE
    local SBOPKGLIST=$SBOPKGTMP/sbopkg_pkglist

    rm -f $SBOPKGLIST
    cd /var/log/packages
    PKGS=$(ls *$REPO_TAG* 2> /dev/null)
    for FILE in $PKGS; do
        echo $FILE >> $SBOPKGLIST
    done
    if [[ -f $SBOPKGLIST ]]; then
        if [[ $DIAG ]]; then
            dialog --title "Installed $REPO_NAME Packages" --textbox \
                $SBOPKGLIST 20 65
        else
            $PAGER $SBOPKGLIST
        fi
    else
        if [[ $DIAG ]]; then
            dialog --title "No packages found" --msgbox "$(crunch_fmt "It \
                appears that you have no $REPO_NAME packages \
                installed.")" 8 40
        fi
    fi
}

progressbar_cli() {
    # This is a simple progressbar for CLI operations.
    # The code shows a bar filling like this:
    #      0%[    ]
    #     25%[=   ]
    #     50%[==  ]
    #     75%[=== ]
    #    100%[====]
    # This is meant to be an "almost drop-in" replacement for
    # "dialog --gauge". The percentage data is read from stdin and the bar
    # fills a screen line.
    #
    # If available, "tput" (part of ncurses) is used to determine the screen
    # width and to hide the cursor.

    local PROGRESS SCREENPROGRESS i
    local SCREENWIDTH BARWIDTH
    local BAR SPACES

    # Initial messages
    if [[ -n "$1" ]]; then
        echo "[ $1 ]"
    fi
    if [[ -n "$2" ]]; then
        crunch_fmt "$2"
    fi

    # Initialize the bar
    # Screen size
    if [[ $HAS_NCURSES ]]; then
        tput civis # Hide cursor
        SCREENWIDTH=$(tput cols)
    else
        SCREENWIDTH=80
    fi
    BARWIDTH=$(($SCREENWIDTH - 8))

    while read PROGRESS; do
        # Show the percentage
        printf "\r%3s%%[" $PROGRESS

        # Draw the bar
        SCREENPROGRESS=$(($BARWIDTH * $PROGRESS / 100))
        printf -vBAR "%${SCREENPROGRESS}s" ""
        printf -vSPACES "%$(($BARWIDTH - $SCREENPROGRESS))s" ""
        printf "%s%s]" "${BAR// /=}" "${SPACES// / }"
    done

    # Cleanup
    echo
    if [[ $HAS_NCURSES ]]; then
        tput cnorm # Restore cursor
    fi
}

progressbar() {
    # This is a simple progressbar gateway, which automatically chooses
    # between the "dialog" and the "cli" bars.

    local MSGTITLE="$1"
    local MSGTEXT="$2"

    if [[ $DIAG ]]; then
        local MESSAGE=$(crunch "$MSGTEXT")
        local MESSAGELINES=$(echo "$MESSAGE" | fmt -66 | wc -l)
        dialog --title "$MSGTITLE" --gauge "$MESSAGE" $(($MESSAGELINES + 5)) \
            70 0
    elif [[ ! $QUIET ]]; then
        progressbar_cli "$MSGTITLE" "$MSGTEXT"
    else
        cat > /dev/null
    fi
}

read_nonblock() {
    # This is a simple non-blocking read function reading a single
    # character (if available) from stdin and putting it in $1.

    local STTY_STATUS=$(stty --save)

    stty -icanon time 0 min 0 -echo
    read $1
    stty $STTY_STATUS
}

progressbar_interrupted() {
    # This function checks whether the user pressed ESC

    local ESC=$'\033' KEY

    read_nonblock KEY
    [[ "$KEY" = "$ESC" ]]
}

get_new_name() {
    # Return the new package name, as for sbopkg-renames.
    # If there isn't any new name, return the old name.
    # $1 = the variable where to put the new name
    # $2 = the old name

    local NEW_NAME_VAR="$1"
    local OLD_NAME="$2"
    local CANDIDATE=$(grep -hr "^$OLD_NAME=" $SBOPKG_RENAMES_D | head -n1)

    if [[ -z "$CANDIDATE" ]]; then
        # No rename occurred
        CANDIDATE="$OLD_NAME"
    else
        # The package got renamed
        CANDIDATE=$(cut -d= -f2 <<< "$CANDIDATE")
    fi
    eval $NEW_NAME_VAR="$CANDIDATE"
}

get_old_name() {
    # Return the old package name if installed, as for sbopkg-renames.
    # If there isn't any old named package installed, return the new name.
    # $1 = the variable where to put the old name
    # $2 = the new name

    local OLD_NAME_VAR="$1"
    local NEW_NAME="$2"
    local CANDIDATE INSTALLED
    local SUBSTITUTIONS=$(grep -hr "=$NEW_NAME\$" $SBOPKG_RENAMES_D | cut -d= -f1)

    # By default, the old name is the new name
    eval $OLD_NAME_VAR=$NEW_NAME
    # Set the old name to the first installed old-named package found.
    # Reading from $substitutions...
    while read CANDIDATE; do
        [[ -z "$CANDIDATE" ]] && continue
        INSTALLED=$(ls /var/log/packages |
            grep -x "$CANDIDATE-[^-]*-[^-]*-[^-]*")
        if [[ -n "$INSTALLED" ]]; then
            # Old-named installed package found, assume this is the correct
            # old name to return.
            eval $OLD_NAME_VAR=$CANDIDATE
            break
        fi
    done <<< "$SUBSTITUTIONS"
}

check_for_updates() {
    # This checks for updates to installed SBo packages.  Thanks to Mauro
    # Giachero for this much-improved update code and related functions!

    local TEMPFILE=$SBOPKGTMP/sbopkg_updates_tempfile
    local NEWSB NEWINFO NEWVER
    local VERSION_EXPRESSION
    local UPDATELIST VERSION_FILE PROGRESSBAR_INTERRUPTED
    local STRING INDEX OLDNAME NAME VER INST_ARCH BUILD
    local VER_NUMERIC NEWVER_NUMERIC UPDATED
    local CURPKG PKGS NUMPKGS PROGRESSCOUNTER=0

    if [[ -z $REPO_TOOL ]]; then
        if [[ $DIAG ]]; then
            dialog --title "ERROR" --msgbox \
                "You cannot check for updates when using the $REPO_DESC." 8 40
        else
            crunch_fmt "You cannot check for updates when using the \
                $REPO_DESC."
        fi
        return 1
    fi
    # Check to see if there are any updates to installed SBo pkgs.
    check_if_repo_exists
    UPDATELIST=$SBOPKGTMP/sbopkg_updatelist
    rm -f $UPDATELIST
    cd /var/log/packages
    PKGS=$(ls *$REPO_TAG 2> /dev/null)
    NUMPKGS=$(wc -w <<< "$PKGS")
    VERSION_FILE=$SBOPKGTMP/sbopkg-script-version
    PROGRESSBAR_INTERRUPTED=$SBOPKGTMP/sbopkg_progressbar-interrupted
    if [[ -z $PKGS ]]; then
        echo "No packages from the $REPO_DESC detected." >> $UPDATELIST
    else
        crunch_fmt "Listing installed $REPO_DESC packages and flagging \
            potential updates..." >> $UPDATELIST
        echo >> $UPDATELIST
        { # Grouping for the progressbar
        echo 0 # Progressbar begin

        for CURPKG in $PKGS; do
            # Bail out if the user pressed ESC
            progressbar_interrupted && touch $PROGRESSBAR_INTERRUPTED && break

            # This next code is borrowed and modified from pkgtool
            STRING=$(basename $CURPKG $REPO_TAG)
            INDEX="$(echo $STRING | tr -d -c -)"
            INDEX="$(expr length $INDEX + 1)"
            OLDNAME=$(expr $INDEX - 3)
            OLDNAME="$(echo $STRING | cut -f 1-$OLDNAME -d -)"
            VER=$(expr $INDEX - 2)
            VER="$(echo $STRING | cut -f $VER -d -)"
            INST_ARCH=$(expr $INDEX - 1)
            INST_ARCH="$(echo $STRING | cut -f $INST_ARCH -d -)"
            BUILD="$(echo $STRING | cut -f $INDEX -d -)"
            # End pkgtool code

            # Manage package renames
            get_new_name NAME $OLDNAME

            # Find the current SlackBuild
            NEWSB=$(find $REPO_DIR -name $NAME.SlackBuild)
                if [[ -z $NEWSB ]]; then
                    # Maybe we're running an old repository where the rename
                    # didn't take place
                    if [[ $NAME != $OLDNAME ]]; then
                        NAME=$OLDNAME
                        NEWSB=$(find $REPO_DIR -name $NAME.SlackBuild)
                    fi
                fi

            # Extract the new package version
            if [[ ! -z $NEWSB ]]; then
                NEWARCH=$(egrep -m1 "^ARCH" $NEWSB | sed -e \
                    's/[ #}\t].*$//;s/^.*[=-]//;s/\"//g')
                NEWBUILD=$(egrep -m1 "^BUILD" $NEWSB | sed -e \
                    's/^.*[=-]//;s/\"//;s/[ #}\t].*$//g;s/\"//g')

                # Step 1 - find the version expression
                # This looks for the last instance of $OUTPUT.
                # Note that part of the name can be returned by mistake,
                # typically for cases such as
                #    makepkg [...] $OUTPUT/$PRGNAM-something-$VERSION-$ARCH-\
                #     $BUILD$TAG
                # This is harmless, and the proper cleanup is performed in
                # Step 4.
                VERSION_EXPRESSION=$(tac $NEWSB | grep -m1 \$OUTPUT/ |
                    cut -d\$ -f2- | cut -d- -f2- | rev | cut -d- -f3- | rev)
                echo "echo $VERSION_EXPRESSION" > $VERSION_FILE

                # Step 2 - find the used variables and their expressions
                # recursively This fills the VERSION_FILE with the proper
                # variables assignments in reversed order (first dependant,
                # then dependencies)
                updates_resolve_expression "$VERSION_EXPRESSION"

                # Step 3 - reverse the file order
                # Because dependencies must be first...
                tac $VERSION_FILE > $TEMPFILE
                mv $TEMPFILE $VERSION_FILE

                # Step 4 - let's get the version number!
                # Also, strip any residual program name token.
                NEWVER=$(sh $VERSION_FILE | rev | cut -d- -f1 | rev)
                rm -f $VERSION_FILE

                # Step 5 - fixup braindead cases
                # Sometimes the above doesn't work -- see cpan2tgz for 12.1
                # In that case, let's trust the .info file...
                if [[ -z $NEWVER ]]; then
                    NEWINFO=$(echo $NEWSB | rev | cut -d. -f2- | rev).info
                    NEWVER=$(grep "^VERSION" $NEWINFO | cut -d\" -f2)
                fi

                # Compare the old $VER and the new $NEWVER
                VER_NUMERIC=$(tr -c "[:digit:]" " " <<< "$VER")
                NEWVER_NUMERIC=$(tr -c "[:digit:]" " " <<< "$NEWVER")
                # The version number must have the same number of digits
                while [[ $(wc -w <<< $VER_NUMERIC) -lt $(wc -w <<< $NEWVER_NUMERIC) ]]; do
                    VER_NUMERIC="$VER_NUMERIC 0"
                done
                while [[ $(wc -w <<< $VER_NUMERIC) -gt $(wc -w <<< $NEWVER_NUMERIC) ]]; do
                    NEWVER_NUMERIC="$NEWVER_NUMERIC 0"
                done
                # The build number is just like the least significant version
                # number
                VER_NUMERIC="$VER_NUMERIC $(tr -c "[:digit:]" ' ' <<< "$BUILD")"
                NEWVER_NUMERIC="$NEWVER_NUMERIC $(tr -c "[:digit:]" ' ' <<< "$NEWBUILD")"
                UPDATED=$(updates_compare_versions $VER_NUMERIC \
                    $NEWVER_NUMERIC)

                if [[ $UPDATED -eq 1 ]]; then
                    echo $NAME: >> $UPDATELIST
                    echo "  POTENTIAL UPDATE" >> $UPDATELIST
                    echo "  Installed version: " $CURPKG >> $UPDATELIST
                    echo "  Repo version: " \
                        $NAME-$NEWVER-$NEWARCH-${NEWBUILD}$REPO_TAG \
                        >> $UPDATELIST
                    echo "$NAME $NEWVER-$NEWBUILD ON" >> \
                        $SBOPKGTMP/sbopkg-update-queue
                elif [[ $UPDATED -eq -1 ]]; then
                    if [[ $DEBUG -ge 1 ]]; then
                        echo $NAME: >> $UPDATELIST
                        echo "  INSTALLED PACKAGE IS NEWER THAN REPO" >> $UPDATELIST
                        echo "  Installed version: " $CURPKG >> $UPDATELIST
                        echo "  Repo version: " $NAME-$NEWVER-$NEWARCH-${NEWBUILD}$REPO_TAG >> $UPDATELIST
                    fi
                else
                    if [[ $DEBUG -eq 2 ]]; then
                        echo $NAME: >> $UPDATELIST
                        echo "  No update." >> $UPDATELIST
                    fi
                fi
            else
                if [[ $DEBUG -ge 1 ]]; then
                    echo $NAME: >> $UPDATELIST
                    echo "  Not in the repository." >> $UPDATELIST
                fi
            fi

            # Progress indicator, for the progressbar
            (( PROGRESSCOUNTER += 1 ))
            echo $(($PROGRESSCOUNTER * 100 / $NUMPKGS))
        done
        } | progressbar "Building list of potential updates" "This may take\
            a few moments depending on how many packages from the $REPO_DESC are\
            installed..."
        echo >> $UPDATELIST
        echo "Potential update list complete." >> $UPDATELIST
    fi
    if [[ ! -f $PROGRESSBAR_INTERRUPTED ]]; then
        if [[ $DIAG ]]; then
            dialog --title "Viewing potential updates" --textbox $UPDATELIST \
                0 0
        else
            cat $UPDATELIST
        fi
        # Permanent log of the updatelist is saved when DEBUG is enabled.
        if [[ $DEBUG -ge 1 ]]; then
            cp $UPDATELIST $SBOPKGTMP/sbopkg-debug-updatelist
        fi
    else
        rm -f $PROGRESSBAR_INTERRUPTED
    fi
}

updates_resolve_expression() {
    # Find the used variables and their expressions recursively
    # Variables == any string made up by letters, digits and underscore
    # This criteria may have false positives, which don't matter since
    # these aren't assigned to in the SlackBuild.
    # 1st parameter == expression (right hand side of FOO=BAR)

    local EXPRESSION_VARIABLES=$(echo $1 | tr -c "[:alnum:]_" " ")
    local VAR
    local ASSIGNMENT

    for VAR in $EXPRESSION_VARIABLES; do
            ASSIGNMENT=$(tac $NEWSB | grep "^$VAR=")
            if [[ ! -z "$ASSIGNMENT" ]] && ! grep -q "^$VAR=" \
                    $VERSION_FILE; then
                echo "$ASSIGNMENT" >> $VERSION_FILE
                updates_resolve_expression "$(cut -d= -f2- <<< "$ASSIGNMENT")"
            fi
    done
}

updates_compare_versions() {
    # Compare numeric versions
    # Takes 2N arguments, where N is the number of numbers (...)
    # composing the version number.
    # E.g. if the two packages are of version 1.2.3 build 7 and
    # 1.2.50 build 4, the argument list is
    # 1 2 3 7 1 2 50 4
    # Prints -1 if the "left" package is newer (not an update), 0 if
    # the version is unchanges, 1 if the "left" package is newer.

    local COUNT=$(($# / 2))
    local i RESULT=0
    local LEFT RIGHT

    for ((i=1; i<=$COUNT; i++)); do
        eval LEFT=\$$i
        eval RIGHT=\${$(($i + $COUNT))}
        if [[ $LEFT -lt $RIGHT ]]; then
            RESULT=1
            break
        elif [[ $LEFT -gt $RIGHT ]]; then
            RESULT=-1
            break
        fi
    done
    echo $RESULT
}

get_category_list() {
    # This function displays the list of SBo categories in the dialog.

    local DIR CAT

    check_if_repo_exists
    cd $REPO_DIR
    rm -f $SBOPKGTMP/sbopkg_category_list
    DIR=( */ )
    if [[ -n $DIR ]]; then
        for CAT in ${DIR[*]%/}; do
            echo "$CAT \"Browse the $CAT category\"" >> \
                $SBOPKGTMP/sbopkg_category_list
        done
    fi
}

checkout_rsync_branch() {
    # This function makes sure that in $REPO_DIR there's the currently
    # selected branch.
    # This is the implementation for rsync repositories, where branches are
    # simple subdirectories

    REPO_DIR=$REPO_DIR/$REPO_BRANCH
}

checkout_git_branch() {
    # This function makes sure that in $REPO_DIR there's the currently
    # selected branch.
    # This is the implementation for git repositories, which is relatively
    # complex because we have to manage local changes.

    local CURRENT_BRANCH NEW_BRANCH NEW_STASH
    local COMMAND_OUTPUT=$SBOPKGTMP/sbopkg_git_checkout_output

    rm -f $COMMAND_OUTPUT

    # Make sure the repository is there
    [[ -d $REPO_DIR/.git ]] || return 0

    # No need to checkout if the right branch is already there
    NEW_BRANCH=$(cut -d@ -f2 <<< $REPO_LINK)
    cd $REPO_DIR
    CURRENT_BRANCH=$(git branch | grep '^*')
    CURRENT_BRANCH=${CURRENT_BRANCH//'* '}
    [[ $CURRENT_BRANCH = $NEW_BRANCH ]] && return 0

    # So we need to checkout the branch. First off, let's clean the tree
    echo "*/*/*.sbopkg" > .gitignore
    git clean -d -f > $COMMAND_OUTPUT
    git reset --hard HEAD >> $COMMAND_OUTPUT

    # Let's save the current user customizations to a stash
    git add . >> $COMMAND_OUTPUT
    git stash save sbopkg-auto-$CURRENT_BRANCH >> $COMMAND_OUTPUT

    # Checkout the user-requested branch
    git checkout $NEW_BRANCH >> $COMMAND_OUTPUT 2>&1

    # Pop the stash of this branch, if any
    NEW_STASH=$(git stash list | grep ": sbopkg-auto-$NEW_BRANCH\$" |
        cut -d: -f1)
    if [[ -n $NEW_STASH ]]; then
        git stash pop $NEW_STASH >> $COMMAND_OUTPUT
        # Make sure no changes are staged
        git reset HEAD >> $COMMAND_OUTPUT
    fi

    # Create a changelog
    # (it makes no sense to have one tracked in a git repo)
    if [[ ! -f ChangeLog.txt ]]; then
        git log --pretty=format:"%cd%n%s%n%b" > ChangeLog.txt
    fi
}

set_repo_vars() {
    # Set REPO_{DESC,TAG,TOOL,LINK,DIR} according to $REPO_{NAME,BRANCH}.
    # Returns nonzero if no match is found.

    local i

    # Make sure we don't return old values with an invalid input
    unset REPO_DESC REPO_TAG REPO_TOOL REPO_LINK REPO_DIR

    for ((i=0; i<${#REPOSITORIES[@]}; i+=6)); do
        if [[ ( ${REPOSITORIES[$i]} = $REPO_NAME || $REPO_NAME = "" ) &&
                ${REPOSITORIES[$((i + 1))]} = $REPO_BRANCH ]]; then
            REPO_NAME=${REPOSITORIES[i]}
            REPO_DESC=${REPOSITORIES[$((i + 2))]}
            REPO_TAG=${REPOSITORIES[$((i + 3))]}
            REPO_TOOL=${REPOSITORIES[$((i + 4))]}
            REPO_LINK=${REPOSITORIES[$((i + 5))]}
            REPO_DIR=$REPO_ROOT/$REPO_NAME

            if [[ $REPO_TOOL = "rsync" || $REPO_TOOL = "git" ]]; then
                checkout_${REPO_TOOL}_branch
            fi
            return 0
        fi
    done

    # Repository/branch not found
    return 1
}

select_repository() {
    # Create menu and list the sbopkg-supported repositories for
    # user to choose from.

    local PID

    while :; do
        eval dialog --cancel-label "Back" --title \
            '"Choose a repository"' \
            --menu '"$(crunch "You are currently using sbopkg to browse a \
            local copy of the $REPO_DESC.  If you would \
            like to change it, please select another repository below or \
            press <Back> to go back.")"' 17 60 6 \
            $(
                for ((i=0; i<${#REPOSITORIES[@]}; i+=6)); do
                    echo \"${REPOSITORIES[$((i+1))]} \(${REPOSITORIES[$i]}\)\"
                    echo \"${REPOSITORIES[$((i+2))]}\"
                done
            ) 2> $SBOPKGTMP/sbopkg_version_selection
        if [[ $? != 0 ]]; then
            break
        fi
        eval $(sed 's:^\(.*\) (\(.*\))$:REPO_NAME=\2;REPO_BRANCH=\1:g' \
            < $SBOPKGTMP/sbopkg_version_selection)
        if [[ $DIAG ]]; then
            (
                sleep 0.2
                dialog --infobox "Checking out..." 3 19
            ) &
            PID=$!
        fi
        set_repo_vars
        [[ $PID ]] && kill $PID 2>/dev/null
        dialog --title "Save this setting?" --defaultno --yesno \
            "$(crunch "Would you like to save this repository setting \
            in the user's $HOME/.sbopkg.conf file? (One will be created if \
            it is not found).\n\nPress <Yes> to save in the user's \
            $HOME/.sbopkg.conf or press <No> to continue without saving, \
            making this a temporary change only.")" 12 60
        if [[ $? != 0 ]]; then
            break
        fi
        if [[ -e $HOME/.sbopkg.conf ]]; then
            sed -i '/^REPO_BRANCH=.*$/d' $HOME/.sbopkg.conf
        fi
        echo "REPO_BRANCH=$REPO_BRANCH" >> $HOME/.sbopkg.conf
        break
    done
    rm -f $SBOPKGTMP/sbopkg_version_selection
}

app_files_chooser() {
    # List the files of a directory, and view the selected ones.
    # This function takes a single argument (the directory whose files are to
    # be listed).

    local DIR=$1
    local DEFAULTITEM
    local AFS=$SBOPKGTMP/sbopkg_app_files_selection
    local AFM=$SBOPKGTMP/sbopkg_app_files_menu
    local TITLE="${D##*/} files"

    while :; do
        find $DIR -type f -printf "\"%P\" \"\"\n" | sort > $AFM
        dialog --ok-label "View" --cancel-label "Back" --title "$TITLE" \
            --default-item "$DEFAULTITEM" --menu "$(crunch "Please choose \
            the file you would like to view or press <Back> to go back.")"\
            15 45 7 --file $AFM 2> $AFS
        if [[ $? != 0 ]]; then
            rm -f $AFS $AFM
            return
        fi
        DEFAULTITEM=$(< $AFS)

        view_app_file $DIR "$DEFAULTITEM"
    done
}

view_app_file() {
    # Decode and view the file $2 in the directory $1

    local DIR=$1
    local FILE="$2"
    local PLAIN
    local AFSP=$SBOPKGTMP/sbopkg_app_files_selection_parsed

    cd $DIR
    case $FILE in
        slack-desc )
            sed -n "/^${DIR##*/}: */s///p" slack-desc > $AFSP ;;
        *tar.gz | *tar.bz2 | *t?z )
            tar tvf $FILE > $AFSP ;;
        *gz ) zcat $FILE > $AFSP ;;
        *bz2 ) bzcat $FILE > $AFSP ;;
        * ) PLAIN=yes ;;
    esac
    if [[ "$PLAIN" == yes ]]; then
        dialog --exit-label "OK" --title "$FILE" --textbox "$FILE" 0 0
    else
        dialog --exit-label "OK" --title "Parsed contents of $FILE" \
            --textbox "$AFSP" 0 0
    fi
    rm -f $AFSP
}

info_item() {
    # This function shows the menu for each package where the user can see
    # certain information or build the package.
    # Returns 0 unless the user asked to jump back to the main menu.

    local OLDPKG CATEGORY SHORTPATH CURVERSION CURARCH CURBUILD
    local CURAPP LONGAPP SHORTAPP
    local STRING INDEX NAME INST_ARCH VER BUILD DEFAULTITEM
    local CURPACKAGE INSTALLEDPACKAGE MENUPACKAGE TITLEPACKAGE RENAMEDPACKAGE
    local CHOICE PARSED_SLACK_DESC
    local APP="$(< $SBOPKGTMP/sbopkg_item_selection)"
    local RETVAL=0

    # We need to check and see if the APP has ever been renamed.
    get_old_name OLDPKG $APP

    CATEGORY="$(< $SBOPKGTMP/sbopkg_category_selection)"
    SHORTPATH=$REPO_DIR/$CATEGORY/$APP
    CURVERSION=$(grep VERSION $SHORTPATH/$APP.info |
        cut -d= -f2 | sed s/\"//g)
    CURARCH=$(egrep -m1 "^ARCH" $SHORTPATH/$APP.SlackBuild |
        sed -e "s/\([^\t #]*\)[\t #].*/\1/;s/[^=]*=//;s/\${[^-]*-\(.*\)}/\1/;\
            s/\$.*/unknown/")
    CURBUILD=$(egrep -m1 "^BUILD" $SHORTPATH/$APP.SlackBuild |
        sed -e 's/^.*[=-]//;s/\"//;s/[ #}\t].*$//g;s/\"//g')
    while :; do
        CURAPP=$(ls /var/log/packages/*$REPO_TAG* 2> /dev/null |
                grep "$APP\|$OLDPKG")
        unset INSTALLEDPACKAGE
        for i in $CURAPP; do
            LONGAPP=$(echo $i | sed "s/$REPO_TAG$//;s/-[^-]*-[^-]*-[^-]*$//")
            SHORTAPP=$(echo $LONGAPP | sed -e 's/^.*\///g')

            if [[ $SHORTAPP == $APP || $SHORTAPP == $OLDPKG ]]; then
                # Again, code from pkgtool
                STRING=$(basename $i $REPO_TAG)
                INDEX="$(echo $STRING | tr -d -c -)"
                INDEX="$(expr length $INDEX + 1)"
                NAME=$(expr $INDEX - 3)
                NAME="$(echo $STRING | cut -f 1-$NAME -d -)"
                VER=$(expr $INDEX - 2)
                VER="$(echo $STRING | cut -f $VER -d -)"
                INST_ARCH=$(expr $INDEX - 1)
                INST_ARCH="$(echo $STRING | cut -f $INST_ARCH -d -)"
                BUILD="$(echo $STRING | cut -f $INDEX -d -)"

                if [[ $SHORTAPP == $APP ]]; then
                    INSTALLEDPACKAGE=$NAME-$VER-$INST_ARCH-$BUILD
                else # Must be a renamed app
                    RENAMEDPACKAGE=$NAME-$VER-$INST_ARCH-$BUILD
                fi
            fi
        done
        if $(echo $(ls -1 $OUTPUT) | grep -E -q "$APP.*$CURVERSION"); then
            CURPACKAGE="$(
                basename $(ls -1 $OUTPUT/${APP}*${CURVERSION}*${CURBUILD}*t?z|
                head -n 1)
                )"
        else
            unset CURPACKAGE
        fi
        if [[ -z $CURPACKAGE ]]; then
            unset MENUPACKAGE
        else
            MENUPACKAGE="Install $CURPACKAGE"
        fi
        if [[ -z $INSTALLEDPACKAGE ]]; then
            if [[ -z $RENAMEDPACKAGE ]]; then
                TITLEPACKAGE="$APP (Not Installed)"
            else
                TITLEPACKAGE="$APP (Installed: $RENAMEDPACKAGE)"
            fi
        else
            TITLEPACKAGE="$APP (Installed: $INSTALLEDPACKAGE)"
        fi
        dialog --default-item "$DEFAULTITEM" \
            --title "$APP ($CURVERSION-$CURARCH-$CURBUILD)" \
            --backtitle "$TITLEPACKAGE" --extra-button --extra-label "Back" \
            --cancel-label "Main Menu" --menu \
            "$(crunch "Please choose an item or press <Back> to go back \
            or press <Main Menu> to return to the main menu.\n")" \
            18 60 10 \
            "README" "View the README file" \
            "Info" "View the .info file" \
            "SlackBuild" "View the SlackBuild file" \
            "More Files" "Choose any file to display" \
            "Custom" "Customize the .info or SlackBuild" \
            "Remove" "Remove $APP sources in cache" \
            "Options" "Edit Build Options/Flavors" \
            "Queue" "Add $APP to build queue" \
            "Build" "Build a package for $APP" \
            $MENUPACKAGE \
            2> $SBOPKGTMP/sbopkg_info_selection
        case $? in
            1 ) # Return to Main Menu
                RETVAL=1; break ;;
            3 ) # Back
                break ;;
            0 ) # OK
                DEFAULTITEM="$(< $SBOPKGTMP/sbopkg_info_selection)"
                CATEGORY="$(< $SBOPKGTMP/sbopkg_category_selection)"
                case $DEFAULTITEM in
                    README )
                        view_app_file $SHORTPATH README
                        ;;
                    Info )
                        view_app_file $SHORTPATH $APP.info
                        ;;
                    SlackBuild )
                        view_app_file $SHORTPATH $APP.SlackBuild
                        ;;
                    "More Files" ) app_files_chooser $SHORTPATH ;;
                    Custom ) customize_item ;;
                    Remove ) remove_sources_for_app $SHORTPATH/$APP.info ;;
                    Options ) add_options $APP ;;
                    Queue ) add_item_to_queue $APP $CURVERSION-$CURBUILD ON ;;
                    Build )
                        echo "$APP" > $SBOPKGTMP/sbopkg-start-queue
                        start_dialog_queue ;;
                    Install )
                        if [[ ! -e $OUTPUT/$CURPACKAGE ]]; then
                              continue;
                        fi
                        install_package $OUTPUT $CURPACKAGE | tee $TMPLOG
                        read -n 1 -p "Press any key to continue."
                        if [[ $KEEPLOG ]]; then
                            cat $TMPLOG >> $LOGFILE
                        fi
                        rm $TMPLOG
                        ;;
                esac
                ;;
            * ) # ESC
                break ;;
        esac
    done

    rm -f $SBOPKGTMP/sbopkg_info_selection
    return $RETVAL
}

customize_item() {
    # This function shows the menu for customizing the SlackBuild
    # and .info file.

    local DEFAULTITEM

    while :; do
    dialog --default-item "$DEFAULTITEM" --title "$APP Customization" \
        --cancel-label "Back" --menu \
        "Please choose an item or press <Back> to go back.\n" 15 75 4 \
        "Edit SlackBuild" "Create and edit a local copy of the SlackBuild" \
        "Delete SlackBuild" "Delete the local copy of the SlackBuild" \
        "Edit Info" "Create and edit a local copy of the .info file" \
        "Delete Info" "Delete the local copy of the .info file" \
        2> $SBOPKGTMP/sbopkg_custom_selection
    if [[ $? = 0 ]]; then
        DEFAULTITEM="$(< $SBOPKGTMP/sbopkg_custom_selection)"
        case $DEFAULTITEM in
            "Edit SlackBuild" )
                edit_local_file SlackBuild $SHORTPATH $APP
                ;;
            "Delete SlackBuild" )
                delete_local_file SlackBuild $SHORTPATH $APP
                ;;
            "Edit Info" )
                edit_local_file info $SHORTPATH $APP
                ;;
            "Delete Info" )
                delete_local_file info $SHORTPATH $APP
                ;;
        esac
    else # Cancel or ESC
        rm -f $SBOPKGTMP/sbopkg_custom_selection
        break
    fi
    done
}

browse_categories() {
    # This function iterates through the category list until one is
    # chosen.

    local DEFAULTITEM

    if [[ -z $(ls -A $REPO_DIR 2> /dev/null) ]]; then
        if [[ $DIAG ]]; then
            dialog --title "ERROR" --msgbox "$(crunch "Repository seems to \
                be empty. Please make sure your repository directory is set \
                correctly and that you have done a sync first.")" 10 30
            continue
        fi
    fi
    get_category_list
    while :; do
        dialog --default-item "$DEFAULTITEM" --cancel-label "Back" \
            --title "Choose a category" --backtitle \
            "Currently using the $REPO_DESC." \
            --menu "Please select a category or press <Back> to go back." \
            23 70 15 --file $SBOPKGTMP/sbopkg_category_list \
            2> $SBOPKGTMP/sbopkg_category_manual_selection
        if [[ $? != 0 ]]; then
            break
        fi
        DEFAULTITEM=$(< $SBOPKGTMP/sbopkg_category_manual_selection)
        gen_search_package '*' $DEFAULTITEM || break
    done
    rm -f $SBOPKGTMP/sbopkg_category_manual_selection
    rm -f $SBOPKGTMP/sbopkg_category_list
}

view_cache_dir() {
    # This function displays the contents of $SRCDIR.

    ls -A $SRCDIR | sed "s/^\(.*\)$/\"\\1\"/g" \
        > $SBOPKGTMP/sbopkg_app_sources
    remove_sources "" OFF
}

view_perm_log() {
    # This function displays the contents of the permanent build log,
    # which is kept if KEEPLOG is set to YES in the config file.

    local VAR_NOTICE HEIGHT

    if [[ ! $KEEPLOG ]]; then
        dialog --title "NOTICE" --msgbox "$(crunch "To use this feature, \
            please make sure KEEPLOG is set to YES in the configuration \
            file.")"  10 30
        return 0
    else
        if [[ ! -e $LOGFILE ]]; then
            dialog --title "NOTICE" --msgbox "$(crunch "No permanent log \
                found.")" 5 30
        return 0
        else
            dialog --title "Displaying $LOGFILE" --textbox $LOGFILE 0 0
            dialog --title "Keep Log?" --yes-label "Keep" \
                --no-label "Delete" --yesno "$(crunch "Would you like to \
                keep the permanent build log $LOGFILE?")" 6 50
            if [[ $? == 1 ]]; then
                rm -f $LOGFILE
                dialog --title "Done" --msgbox \
                    "The build log has been deleted." 8 30
                continue
            fi
        fi
    fi
}

empty_queue() {
    # This function tests whether the temporary build queue is empty.

    if [[ ! -e $TMPQUEUE ]]; then
        if [[ $DIAG ]]; then
            dialog --title "Empty Queue" --msgbox \
                "The build queue is empty." 8 30
        else
            echo "The build queue is empty."
        fi
        return 0
    else
        return 1
    fi
  }

sort_queue() {
    # This function sorts the build queue in $TMPQUEUE.

    local PARTIALSORT=$SBOPKGTMP/sbopkg_sort_tempfile
    local CHOICE
    local SELECTED
    local PKGSCOUNT=$(wc -l < $TMPQUEUE)
    local DEFAULTITEM
    local TMPSORTQUEUE=$SBOPKGTMP/sbopkg-tmp-sort-queue

    cp $TMPQUEUE $TMPSORTQUEUE
    while :; do
        dialog --title "Sort Queue" --ok-label "Up" \
            --extra-button --extra-label "Down" \
            --cancel-label "OK" \
            --help-button --help-label "Cancel" \
            --default-item "$DEFAULTITEM" \
            --menu "$(crunch "Use the <Up/Down> buttons to sort the queue \
            items, press <OK> when done, or press <Cancel> to abort \
            changes.")" 30 50 14 \
            $(nl $TMPSORTQUEUE | rev | cut -d" " -f3 | rev) \
            2> $SBOPKGTMP/sbopkg-ans-sort
        CHOICE=$?
        SELECTED=$(< $SBOPKGTMP/sbopkg-ans-sort)
        DEFAULTITEM=$SELECTED
        case $CHOICE in
            0 ) # Up
                if [[ $SELECTED -eq 1 ]]; then
                    continue
                fi
                head -n $(($SELECTED-2)) $TMPSORTQUEUE > $PARTIALSORT
                head -n $(($SELECTED)) $TMPSORTQUEUE |
                    tail -n 1 >> $PARTIALSORT
                head -n $(($SELECTED-1)) $TMPSORTQUEUE |
                    tail -n 1 >> $PARTIALSORT
                tail -n $(($PKGSCOUNT-$SELECTED)) $TMPSORTQUEUE >> \
                    $PARTIALSORT
                mv $PARTIALSORT $TMPSORTQUEUE
                DEFAULTITEM=$(($SELECTED-1))
                continue
                ;;
            1 ) # OK
                mv $TMPSORTQUEUE $TMPQUEUE
                break
                ;;
            3 ) # Down
                if [[ $SELECTED -eq $PKGSCOUNT ]]; then
                    continue
                fi
                head -n $(($SELECTED-1)) $TMPSORTQUEUE > $PARTIALSORT
                head -n $(($SELECTED+1)) $TMPSORTQUEUE |
                    tail -n 1 >> $PARTIALSORT
                head -n $(($SELECTED)) $TMPSORTQUEUE |
                    tail -n 1 >> $PARTIALSORT
                tail -n $(($PKGSCOUNT-$SELECTED-1)) $TMPSORTQUEUE >> \
                    $PARTIALSORT
                mv $PARTIALSORT $TMPSORTQUEUE
                DEFAULTITEM=$(($SELECTED+1))
                continue
                ;;
            * ) # Cancel or ESC
                rm -f $TMPSORTQUEUE
                break
                ;;
        esac
    done
    rm -f $SBOPKGTMP/sbopkg-ans-sort
    continue
}

queue_dir_lister() {
    # This function produces a checklist from the contents of the QUEUEDIR and
    # takes two arguments - the title and the text of the widget - and makes
    # the selected item(s) from the listing available as USERQUEUE

    local QFS=$SBOPKGTMP/sbopkg_queue_files_selection
    local QFM=$SBOPKGTMP/sbopkg_queue_files_menu

    if [[ -z $(ls -A $QUEUEDIR/*.sboq 2> /dev/null) ]]; then
        if [[ $DIAG ]]; then
            dialog --title "ERROR" --msgbox "$(crunch "The queue directory \
                $QUEUEDIR is empty.")" 8 30
            continue
        fi
    fi
    find $QUEUEDIR -type f -name '*.sboq' -printf "\"%P\" \"\" off\n" \
        | sed -e 's/.sboq//' | sort > $QFM
    # The --default item doesn't work on deletions and renames (because the
    # variable expands to a no-longer existing file) but you can't give it an
    # index argument, unfortunately
    dialog --title "$1" --default-item "${USERQUEUE##*/}" \
        --cancel-label "Back" --checklist "$2" 20 40 8 --file $QFM 2> $QFS
    if [[ $? != 0 ]]; then
        # unset this so there's no left over junk and the loop from the
        # calling functions doesn't kick in when this returns to them
        unset USERQUEUE
        return 0
    fi
    USERQUEUE=( $(< $QFS) )
}

can_skip_line() {
    # This function reads in a line and checks if it is blank or starts with a
    # comment.

    echo $1 | grep "^#" > /dev/null
    if [[ $? == 0 ]]; then
        return 0
    fi
    if [[ "$1" == "" ]]; then
        return 0
    fi
    return 1
}

load_user_queue() {
    # This function loads a user's specified saved queue and merges it

    local USERQUEUE_LOCK=$SBOPKGTMP/sbopkg_user_queue.lck

    queue_dir_lister "Load Queue" "$(crunch "Select the queue(s) you \
        wish to load and choose <OK> or choose <Back> to \
        leave this menu.")"

    for ((i=0; i<${#USERQUEUE[*]}; i++)); do
        FILE=$QUEUEDIR/${USERQUEUE[$i]//'"'/}
        FILE="$FILE.sboq"
        if [[ -r $FILE ]]; then
            CLIQUEUEFILE=$FILE
            # this inhibits add_item_to_queue's msgbox for each added app
            touch $USERQUEUE_LOCK
            echo "Reading the queuefile, please be patient..."
            # Reading from $FILE...
            while read PICK; do
                if can_skip_line $PICK; then
                    continue
                fi
                add_item_to_queue $PICK
            done < $FILE
            LAST_USER_QUEUE_ON_DISK=$FILE
            rm -f $USERQUEUE_LOCK
        else
            dialog --title "ERROR" --msgbox \
                "$FILE is not readable or does not exist" 0 0
            return 1
        fi
    done
}

delete_user_queue() {
    # This function deletes queues

    queue_dir_lister "Delete Queue" "$(crunch "Select the queue(s) you \
        wish to delete and choose <OK> or choose <Back> to \
        leave this menu.")"

    for ((i=0; i<${#USERQUEUE[*]}; i++)); do
        FILE=$QUEUEDIR/${USERQUEUE[$i]//'"'/}
        FILE="$FILE.sboq"
        if ! rm -f $FILE 2> /dev/null; then
            dialog --title "ERROR" --msgbox \
                "You do not have permission to remove $FILE" 0 0
            return 1
        fi
    done
}

validate_queue_name() {
    # Validate the queue name stored in the file $1.
    # Shows an error message and returns nonzero in case of invalid queue
    # name.

    local QF="$1"

    if grep -q [^[:alnum:]_-] $QF; then
        # this doesn't prevent the user from putting 'dumb"filename' in the
        # directory manually, but helps prevent breaking sbopkg from sbopkg -
        # and I could allow more characters, but these should be enough
        dialog --title "ERROR" --msgbox "$(crunch "Sorry, \
            but this interface supports filenames containing \
            only alphanumeric characters, dashes, and \
            underscores.")" 0 0
        return 1
    fi
    return 0
}

rename_user_queue() {
    # This function renames queues

    local QRN=$SBOPKGTMP/sbopkg-queue-rename
    local NEWNAME COUNTER FILE

    queue_dir_lister "Rename Queue" "$(crunch "Select the queue(s) you \
        wish to rename and choose <OK> or choose <Back> to \
        leave this menu.")"

    # I have to assign to this because I shrink the array later
    COUNTER=${#USERQUEUE[*]}
    for ((i=0; i<$COUNTER; i++)); do
        FILE=$QUEUEDIR/${USERQUEUE[$i]//'"'/}
        FILE="$FILE.sboq"
        if [[ -w ${FILE%/*} ]]; then
            # This loops so the user can be brought back to the inputbox on a
            # failure (continue) or back to the dir lister on success (break)
            while :; do
                dialog --title "Rename Queue" \
                    --inputbox "Enter the new filename for ${USERQUEUE[$i]}" \
                    0 0 $NEWNAME 2> $QRN
                NEWNAME="$(< $QRN)"
                if [[ $? == 0 ]]; then
                    if ! validate_queue_name $QRN; then
                        continue
                    elif [[ -f $QUEUEDIR/$NEWNAME ]]; then
                        dialog --title "ERROR" --msgbox "$(crunch "File \
                            exists. Please choose another name.")" 0 0
                        continue
                    else
                        mv "$FILE" "$QUEUEDIR/$NEWNAME.sboq"
                        break
                    fi
                else
                    continue 2
                fi
            done
            # I've already forgotten why this is here, but it was important
            unset USERQUEUE[$i]
        else
            dialog --title "ERROR" --msgbox \
                "You do not have permission to rename $USERQUEUE" 0 0
            return 1
        fi
    done
}

save_user_queue() {
    # This function saves the build queue to the filename the user specifies.
    # If --end is specified as first parameter, assume that the user is
    # exiting sbopkg and that this call is about saving the currently active
    # queue. In that case, show the filename dialog only if there actually is
    # an active queue, and return silently otherwise.

    local SAVEQUEUE=$SBOPKGTMP/sbopkg-tmpsave-queue
    local USERQUEUE=$SBOPKGTMP/sbopkg-user-queue
    local DEFAULT MSG USERQUEUE_NAME i
    local USERQUEUE_NAME PICK SAVENAME SAVEONOFF

    rm -f $SAVEQUEUE
    # Reading from $TMPQUEUE...
    while read PICK; do
        SAVENAME=$(echo $PICK | cut -d ' ' -f1)
        SAVEONOFF=$(echo $PICK | cut -d ' ' -f3)
        if [[ $SAVEONOFF =~ [oO][nN] ]]; then
            echo $SAVENAME >> $SAVEQUEUE
        else
            echo "-$SAVENAME" >> $SAVEQUEUE
        fi
    done < $TMPQUEUE
    if [[ $1 == "--end" ]]; then
        if [[ ! -s $TMPQUEUE ]]; then
            return 1
        elif [[ -f $LAST_USER_QUEUE_ON_DISK ]] &&
                diff $LAST_USER_QUEUE_ON_DISK $SAVEQUEUE > /dev/null; then
            # The active queue is unchanged since the last loaded/saved one
            return 0
        else
            MSG=$(crunch "A current queue is active. Please enter the \
                filename you wish to save your queue as or choose <Cancel> \
                to discard it")
            # Find an unused automatic file name
            i=0
            while [[ -f $QUEUEDIR/sbopkg-autosave-$i.sboq ]]; do
                (( i++ ))
            done
            DEFAULT=sbopkg-autosave-$i
        fi
    else
        if empty_queue; then
            return 0
        else
            MSG=$(crunch "Please enter the filename you wish to save your \
                queue as:")
        fi
    fi

    while :; do
        dialog --title "Save Queue" --inputbox "$MSG" 10 50 $DEFAULT \
            2> $USERQUEUE
        if [[ $? == 0 ]]; then
            if [[ ! -s $USERQUEUE ]]; then
                break
            fi
            USERQUEUE_NAME="$(< $USERQUEUE)"
            DEFAULT="${USERQUEUE_NAME##*/}"
            if ! validate_queue_name $USERQUEUE; then
                continue
            fi
            if [[ -e $USERQUEUE_NAME.sboq ]]; then
                dialog --title "ERROR" --yesno "$(crunch "Another file \
                    with that name already exists.  Press <Yes> to \
                    continue and overwrite the other file, or press <No> \
                    to cancel.")" 10 50
                if [[ $? != 0 ]]; then
                    continue
                fi
            fi
            if cp $SAVEQUEUE $QUEUEDIR/$USERQUEUE_NAME.sboq; then
                LAST_USER_QUEUE_ON_DISK=$QUEUEDIR/$USERQUEUE_NAME.sboq
            else
                dialog --title "ERROR" --msgbox "Problem saving build queue."\
                    8 30
            fi
        fi
        break
    done
}

edit_build_queue() {
    # This function deletes items in the build queue.

    local ANSQUEUE=$SBOPKGTMP/sbopkg-ans-queue
    local REMOVEQUEUE=$SBOPKGTMP/sbopkg-remove-queue
    local WORKINGQUEUE=$SBOPKGTMP/sbopkg-working-queue
    local CHOICE REMOVE REMOVED

    empty_queue && return
    sed 's/ ON$//g;s/ OFF$//g' $TMPQUEUE > $REMOVEQUEUE
    while :; do
        # "dialog" segfaults when asked to display an empty menu. Work around
        # this by showing an "empty" entry when there are no more items in the
        # queue.
        if [[ $(wc -w < $REMOVEQUEUE) -eq 0 ]]; then
            echo '"" "The queue is empty."' > $REMOVEQUEUE
        fi
        dialog --title "Edit Build Queue" --ok-label "Delete" \
            --extra-button --extra-label "Clear" --help-button \
            --help-label "Done" --cancel-label "Cancel" \
            --menu "$(crunch "The following packages are currently in \
            the build queue.  You can remove individual items from the build \
            queue by highlighting them and pressing <Delete>.  Press <Done> \
            when you are finished and the individual deletions will be \
            committed.  Otherwise, press <Cancel> at any time to abort your \
            changes.\n\nYou can also press <Clear> to immediately \
            clear the queue.  This cannot be undone.")" 25 60 8 \
            --file $REMOVEQUEUE 2> $ANSQUEUE
        CHOICE=$? # 0 = Delete, 1 = Cancel, 2 = Done, 3 = Delete All
        REMOVED=$(< $ANSQUEUE)
        case $CHOICE in
            0)
                echo $REMOVED >> $WORKINGQUEUE
                sed -i "/^$REMOVED .*$/d" $REMOVEQUEUE
                continue
                ;;
            1)
                rm -f $REMOVEQUEUE
                return 0
                ;;
            2)
                if [[ ! -e $WORKINGQUEUE ]]; then
                    rm -f $REMOVEQUEUE
                    break
                fi
                for REMOVE in $(< $WORKINGQUEUE); do
                    sed -i "/^$REMOVE .*$/d" $TMPQUEUE
                done
                if [[ ! -s $TMPQUEUE ]]; then
                    rm -f $TMPQUEUE
                fi
                dialog --title "Done" --msgbox \
                    "The items have been removed from the build queue." 8 30
                return 0
                ;;
            3)
                rm -f $REMOVEQUEUE $TMPQUEUE
                dialog --title "Done" --msgbox \
                    "The build queue has been cleared." 8 30
                return 0
                ;;
        esac
    done
}

add_item_to_queue() {
    # This function can take up to three arguments: APP, VERSIONBUILD, and
    # ONOFF and normally does when items are added to the build queue from the
    # dialog menus.  However, saved user queues only have one item per line,
    # which is the application name.  If the application was deselected when
    # the queue was saved, then a '-' is appended to the front of the
    # application name in the queuefile.  This means that, when
    # load_user_queue reads each line of a saved queuefile and sends it to
    # add_item_to_queue, the second and third arguments will be empty.
    # Therefore, the start of this function first tests to see if the second
    # argument is empty.  If so, then it proceeds to gather information about
    # the application like the VERSION and BUILD, and then sets ONOFF to 'OFF'
    # if the first character was '-' otherwise it is set to 'ON'.  If we
    # have all three arguments, then we continue on.  If APP is already in the
    # queue and is of a different version, ask user if they want to replace it
    # (so updated pkgs will get updated in the queue).

    local APP=$1
    local VERSIONBUILD=$2
    local ONOFF=$3
    local BACKUPQUEUE_LOCK=$SBOPKGTMP/sbopkg_backup_queue.lck
    local USERQUEUE_LOCK=$SBOPKGTMP/sbopkg_user_queue.lck
    local UPDATEQUEUE=$SBOPKGTMP/sbopkg-update-queue
    local TESTONOFF PRGNAM VERSION HOMEPAGE DOWNLOAD MD5SUM MAINTAINER EMAIL
    local APPROVED BUILD

    if [[ -z $VERSIONBUILD ]]; then
        if [[ ${APP:0:1} == "-" ]]; then
            APP=${APP:1}
            ONOFF=OFF
        else
            ONOFF=ON
        fi
        search_package $APP
        . $PKGPATH/$APP.info
        BUILD=$(egrep -m1 "^BUILD" $PKGPATH/$APP.SlackBuild |
            sed -e 's/^.*[=-]//;s/\"//;s/[ #}\t].*$//g;s/\"//g')
        VERSIONBUILD="$VERSION-$BUILD"
    fi
    if grep -q "^$APP " $TMPQUEUE 2> /dev/null; then
        : # it's the same app and version so toss it
    else
        echo "$APP $VERSIONBUILD $ONOFF" >> $TMPQUEUE
    fi
    # Only display this if we are not loading a queue; otherwise getting this
    # after each app was added to the queue may get annoying.
    if [[ ! -e $USERQUEUE_LOCK &&
            ! -e $BACKUPQUEUE_LOCK &&
            ! -e $UPDATEQUEUE ]]; then
        dialog --title "Done" --msgbox "$(crunch "$APP has been added to \
            the build queue.")" 8 40
    fi
}

view_queue() {
    # This function displays the contents of the build queue.
    # Returns 0 if the user choose OK, nonzero otherwise

    local ANSQUEUE=$SBOPKGTMP/sbopkg-ans-queue
    local REVERSEDQUEUE=$SBOPKGTMP/sbopkg-reversed-queue
    local WORKINGQUEUE=$SBOPKGTMP/sbopkg-working-queue

    empty_queue && return 1
    while :; do
        dialog --title "Viewing Build Queue" --separate-output \
            --extra-button --extra-label "Reverse" \
            --help-button --help-label "Back" --cancel-label "Sort" \
            --checklist "$(crunch "The following packages are currently \
            in the build queue.  Please note that when the build queue \
            is processed, the packages selected below will be built, and \
            optionally installed, in the order listed from top to \
            bottom.\n\nPlease select or unselect those packages you wish \
            to keep in the build queue and then press <OK> to continue \
            or press <Cancel> to exit.")" 30 50 8 \
            --file $TMPQUEUE 2> $ANSQUEUE
        case $? in # 0 = OK, 1 = Sort, 2 = Cancel, 3 = Reverse
            0)
                rm -f $WORKINGQUEUE
                # Reading from $TMPQUEUE...
                while read PICK; do
                    TESTAPP="${PICK// */}"
                    if grep -qx "$TESTAPP" $ANSQUEUE; then
                        sed 's/OFF/ON/' <<< "$PICK" >> $WORKINGQUEUE
                    else
                        sed 's/ON/OFF/' <<< "$PICK" >> $WORKINGQUEUE
                    fi
                done < $TMPQUEUE
                mv $WORKINGQUEUE $TMPQUEUE
                return 0
                ;;
            1)
                sort_queue $TMPQUEUE
                continue
                ;;
            3)
                tac $TMPQUEUE > $REVERSEDQUEUE
                mv $REVERSEDQUEUE $TMPQUEUE
                continue
                ;;
            *) # Cancel or ESC
                rm -f $ANSQUEUE
                break
                ;;
        esac
    done
    rm -f $WORKINGQUEUE
    return 1
}

rsync_command() {
    # This function holds the rsync command.
    # We do not use -z as this causes heavy CPU load on the server and has
    # very limited effect when most of the pull is .gz files.

    local SYNC_LOCK=$SBOPKGTMP/sbopkg_sync.lck

    rsync --archive --delete --no-owner --exclude="*.sbopkg" \
        $RSYNCFLAGS $REPO_LINK/ $REPO_DIR/
    case $? in
        35)
            echo
            echo "The connection to $REPO_LINK timed out."
            echo "You can modify the TIMEOUT value in sbopkg.conf"
            echo "if this problem persists."
            echo "(TIMEOUT is currently set to:  $TIMEOUT seconds)".
            echo
            ;;
        30)
            echo
            echo "Rsync reported a timeout while waiting for data."
            echo "$REPO_LINK may under a heavy load."
            echo "Please try again later."
            echo
            ;;
        10)
            echo
            echo "Rsync reported a socket error which may be due to"
            echo "a problem with the LINK value in sbopkg.conf."
            echo "(The repo's LINK is currently set to: $REPO_LINK)."
            echo "Please check your settings and try again later."
            echo
            ;;
        0)
            echo
            echo "Rsync with the $REPO_DESC complete."
            echo
            ;;
        *)
            echo
            echo "Rsync with the $REPO_DESC failed."
            echo "Please try again."
            echo
            ;;
    esac
    rm -f $SYNC_LOCK
}

git_command() {
    # This function synchronizes a local git repository with upstream.

    local SYNC_LOCK=$SBOPKGTMP/sbopkg_sync.lck
    local URL BRANCH CWD

    eval $(sed 's/^\(.*\)@\(.*\)$/URL=\1; BRANCH=\2/g' <<< $REPO_LINK)

    CWD=$(pwd)
    # Create the repository if needed
    if [[ ! -d $REPO_DIR/.git ]]; then
        mkdir -p $REPO_DIR
        cd $REPO_DIR
        git init
    fi
    # Update the repository
    cd $REPO_DIR
    git pull $URL $BRANCH
    # Remove leftovers
    # This is optional, think of it as a way to emulate the --delete --exclude
    # rsync directives
    echo "*/*/*.sbopkg" > .gitignore
    git clean -d -f
    git reset --hard HEAD
    # Create a changelog
    # (it makes no sense to have one tracked in a git repo)
    if [[ ! -f ChangeLog.txt ]]; then
        git log --pretty=format:"%cd%n%s%n%b" > ChangeLog.txt
    fi
    # All done
    rm -f $SBOPKGTMP/sbopkg_sync.lck
    echo
    echo "Repository update complete."
    echo
}

sync_repo() {
    # This function does the sync with SBo.

    local SYNC_LOCK=$SBOPKGTMP/sbopkg_sync.lck

    if [[ $REPO_TOOL == "" ]]; then
        if [[ $DIAG ]]; then
            dialog --title "ERROR" --msgbox \
                "You cannot sync the $REPO_DESC." 8 40
        else
            crunch_fmt "You cannot sync the $REPO_DESC."
        fi
        continue
    fi
    directory_checks
    if ! check_write $REPO_DIR; then
        if [[ $DIAG ]]; then
            dialog --title "ERROR" --msgbox \
                "You do not have write permissions on the target directory." \
                8 30
            continue
        else
            crunch_fmt "You do not have write permissions on the target \
                directory." >&2
            cleanup
            exit 1
        fi
    elif [[ $REPO_TOOL != "rsync" && $REPO_TOOL != "git" ]]; then
        if [[ $DIAG ]]; then
            dialog --title "ERROR" --msgbox \
                "Unsupported fetching tool \"$REPO_TOOL\"." 8 30
            continue
        else
            echo "Unsupported fetching tool \"$REPO_TOOL\"."
            cleanup
            exit 0
        fi
    fi
    if [[ $DIAG ]]; then
        touch $SYNC_LOCK
        ( ${REPO_TOOL}_command >> $SBOPKGOUTPUT & ) 2>> $SBOPKGOUTPUT
        while [[ -f $SYNC_LOCK ]]; do
            dialog --backtitle "Updating the active repository" \
                --tailbox $SBOPKGOUTPUT 18 70
        done
        rm -f $SBOPKGOUTPUT
    else
        ${REPO_TOOL}_command
    fi
}

search_package() {
    # Search for package name and return error if not found.
    # $1 = the name of the package we're looking for
    # Returns 0 and sets PKGPATH if the package is found. Returns 1 otherwise.

    local PKG

    cd $REPO_DIR
    PKG="$1"
    PKGPATH=( $(find -type d -mindepth 2 -name "$PKG") )

    if [[ -z $PKGPATH ]]; then
        return 1
    else
        return 0
    fi
}

gen_search_package() {
    # Search for package name glob generally using grep.  In dialog interface,
    # jump to selected package.
    # Returns 0 unless the user asked to jump back to the main menu.

    cd $REPO_DIR
    local PKG=$1
    local CATEGORY=${2:-\*}
    local RETVAL=0
    local CAT_SELECTION=$SBOPKGTMP/sbopkg_category_selection
    local ITEM_SELECTION=$SBOPKGTMP/sbopkg_item_selection
    local SEARCH_CHOICE=$SBOPKGTMP/sbopkg_search_choice
    local SEARCH_RESULTS=$SBOPKGTMP/sbopkg_search_results
    local RESULTS=$(find -mindepth 2 -maxdepth 2 -type d \
        -iwholename "./$CATEGORY/*$PKG*" -printf "%P\n" | sort)
    local NAME DESC CHOICE
    local SRCHPICK SRCHCAT SRCHPKG
    local SHORTPATH RVERSION RBUILD

    if [[ $RESULTS ]]; then
        if [[ $DIAG ]]; then
            for i in $RESULTS; do
                DESC=$(grep -hZm1 ^$(cut -d/ -f2 <<< "$i") ./$i/slack-desc* |
                    sed 's/^[^(]*( *\(.*[^ ]\) *)[^)]*$/\1/;s/"/'\''/g')
                if [[ $CATEGORY == '*' ]]; then
                    NAME=$i
                else
                    NAME=$(cut -d/ -f2 <<< "$i")
                fi
                echo "\"$NAME\" \"$DESC\"" >> $SEARCH_RESULTS
            done
            while [[ -f $SEARCH_RESULTS ]]; do
                # The default item can be "". In that case, dialog defaults to
                # the first item.
                dialog --title "Matches for $PKG in $CATEGORY" \
                    --backtitle "$(crunch "Currently using the \
                    $REPO_DESC.")" \
                    --default-item "$SRCHPICK" --extra-button \
                    --cancel-label "Back" \
                    --help-button --help-label "Main Menu" \
                    --extra-label "Add to Queue" --menu "$(crunch "Please \
                    select an item you wish to view, press <Add to Queue> \
                    to add it to the build queue, or press <Back> to \
                    go back.")" 22 70 14 --file \
                    $SEARCH_RESULTS 2> $SEARCH_CHOICE
                CHOICE=$?
                if [[ $CHOICE =~ '^(1|255|-1)$' ]]; then
                    # Back or ESC
                    break
                elif [[ $CHOICE == 2 ]]; then
                    # Main Menu
                    RETVAL=1
                    break
                fi
                SRCHPICK="$(< $SEARCH_CHOICE)"
                if [[ $CATEGORY == '*' ]]; then
                    SRCHCAT="${SRCHPICK%%/*}"
                else
                    SRCHCAT=$CATEGORY
                fi
                echo $SRCHCAT > $CAT_SELECTION
                SRCHPKG="${SRCHPICK##*/}"
                SHORTPATH=$REPO_DIR/$SRCHCAT/$SRCHPKG
                RVERSION=$(grep VERSION $SHORTPATH/$SRCHPKG.info |
                    cut -d= -f2 | sed s/\"//g)
                RBUILD=$(egrep -m1 "^BUILD" $SHORTPATH/$SRCHPKG.SlackBuild |
                    sed -e 's/^.*[=-]//;s/\"//;s/[ #}\t].*$//g;s/\"//g')
                if [[ $CHOICE == 0 ]]; then
                    echo $SRCHPKG > $ITEM_SELECTION
                    cd $REPO_DIR
                    if ! info_item; then
                        RETVAL=1
                        break
                    fi
                else # $CHOICE = 3
                    add_item_to_queue $SRCHPKG $RVERSION-$RBUILD ON
                    break
                fi
            done
        else
            echo "Found the following matches for $PKG:"
            for i in $RESULTS; do
                echo $i
            done
        fi
    else
        if [[ $DIAG ]]; then
            dialog --title "ERROR" --msgbox "No match for $PKG found" 8 30
        else
            echo "$SCRIPT: No match for $PKG found." >&2
        fi
    fi

    rm -f $SEARCH_RESULTS $SEARCH_CHOICE $CAT_SELECTION $ITEM_SELECTION
    return $RETVAL
}

string_search() {
    # If the search string is prefixed with 'inst:', then the user only wants
    # to search installed packages, so this shaves the 'inst:' off, and
    # generates a potentially huge path consisting only of installed *SBo
    # packages to hand to find. Otherwise, just search for $1 in REPO as
    # usual.
    # Returns 0 unless the user asked to jump back to the main menu.

    if [[ ${SEARCH_TERM%%:*} == "inst" ]]; then
        local SEARCH_TERM="${SEARCH_TERM#*:}"
        local SBOPKGS=($(ls /var/log/packages/*$REPO_TAG))
        for ((i=0; i<${#SBOPKGS[*]}; i++)); do
            local PKGNAME=$(
                sed 's,.*/,,;s/-[^-]*-[^-]*-[^-]*$//' <<< "${SBOPKGS[$i]}")
            local INST_PKGS+="$REPO_DIR/*/$PKGNAME "
        done
        local FIND_PATH="$INST_PKGS"
    else
        local SEARCH_TERM="$1"
        local FIND_PATH="$REPO"
    fi
    local CAT_SELECTION=$SBOPKGTMP/sbopkg_category_selection
    local ITEM_SELECTION=$SBOPKGTMP/sbopkg_item_selection
    local MENU_FILE=$SBOPKGTMP/sbopkg_menu-file
    local PICKED_FILE=$SBOPKGTMP/sbopkg_picked-file
    local PICKED

    # The sed expression processes find's output into data usable for the menu
    # file but the first two parts are needed to sanitize the input - which
    # raises the question of true general sanitizing of this input
    ( find $FIND_PATH -iname 'README' -exec egrep -iwm1 "$SEARCH_TERM" {} + |
        sed "
            s,\",\',g
            s/\\\/\\\\\\\\/g
            s,$REPO_DIR/,,
            s/^/\"/
            s,/README:,\" \",
            s/$/\"/
        " | sort > $MENU_FILE
    ) 2> /dev/null

    if [[ ! -s $MENU_FILE ]]; then
        dialog --title "ERROR" --msgbox "No match for $SEARCH_TERM found" 8 30
        return 0
    fi

    cd $REPO_DIR

    while :; do
        dialog --title "String Search Results" --default-item "$PICKED" \
            --extra-button --extra-label "Add to Queue" \
            --cancel-label "Back" \
            --menu "$(crunch "Please select an item you wish to view or \
                press <Add to Queue> to add it to the build queue or \
                press <Back> to go back.")" 0 0 0 \
            --file $MENU_FILE 2> $PICKED_FILE

        BUTTON=$?
        PICKED=$(< $PICKED_FILE)

        # Duplicate (except slightly modified) code from gen_package_search()
        SRCHCAT=${PICKED%%/*}
        echo $SRCHCAT > $CAT_SELECTION
        SRCHPKG=${PICKED##*/}

        case $BUTTON in
            0)
                echo $SRCHPKG > $ITEM_SELECTION
                if ! info_item; then
                    rm -f $PICKED_FILE $MENU_FILE $CAT_SELECTION \
                        $ITEM_SELECTION
                    return 1
                fi
                ;;
            3)
                SHORTPATH=$REPO_DIR/$SRCHCAT/$SRCHPKG
                RVERSION=$(grep VERSION $SHORTPATH/$SRCHPKG.info |
                    cut -d= -f2 | sed s/\"//g)
                RBUILD=$(egrep -m1 "^BUILD" $SHORTPATH/$SRCHPKG.SlackBuild |
                    sed -e 's/^.*[=-]//;s/\"//;s/[ #}\t].*$//g;s/\"//g')
                add_item_to_queue $SRCHPKG $RVERSION-$RBUILD ON
                continue
                ;;
            *)
                rm -f $PICKED_FILE $MENU_FILE $CAT_SELECTION $ITEM_SELECTION
                return 0
            ;;
        esac
    done
}

show_readme() {
    # Show the package's text files.
    # $1 = Package path
    # $2 = Package name

    local PKGPATH=$1
    local PKGNAME=$2

    cd $REPO_DIR
    $PAGER \
        $PKGPATH/{README,$PKGNAME.SlackBuild,$PKGNAME.info.build,slack-desc}
    rm -f $PKGPATH/$PKGNAME.info.build
    return 0
}

get_source_names() {
    # Echo the source names for an app, given the info file.
    # Usage: get_source_names [--all] info_file
    #   --all   try to find all source files (i.e. also the obsolete ones)

    local SRCNAME INFO ALL CWD
    # Don't pollute the environment with the .info content...
    local PRGNAM VERSION HOMEPAGE DOWNLOAD MD5SUM MAINTAINER EMAIL APPROVED

    if [[ $1 == "--all" ]]; then
        ALL=yes
        shift
    fi
    INFO="$1"

    . $INFO
    SRCNAME=${DOWNLOAD##*/}
    # Replace URI hex sequences (like %20 for ' ' and %2B for '+') with their
    # corresponding characters.
    # This is done replacing '%' with '\x' and passing the string to printf.
    if [[ $SRCNAME =~ % ]]; then
        SRCNAME=$(printf ${SRCNAME//\%/\\x})
    fi
    # The above doesn't work when the download link doesn't reference the file
    # name explicitly. If this is the case, all we can do is guessing...
    if [[ ! $SRCNAME ]]; then
        # If the source has a name resembling $PRGNAM-$VERSION.tar.gz, catch
        # it.
        CWD=$(pwd)
        cd $SRCDIR
        SRCNAME=$(find . -iname $PRGNAM\*$VERSION.\* | head -n 1)
        cd "$CWD"
        if [[ ! $SRCNAME ]]; then
            # We do our best with the tools we have...
            SRCNAME=$PRGNAM-$VERSION.tar.gz
        fi
    fi

    # If the user asked for "all" sources, let's try to find similar names
    if [[ $ALL ]]; then
        # The following is based on the idea that the source name contains the
        # version number. The expression below takes the parts before and
        # after the version number, and replaces the version number with a
        # regular expression matching and digit and any character present in
        # the known version number (this is to match odd version numbers
        # containing letters, like "svn1234", but makes it less likely to
        # match different packages with similar names, like virtualbox-kernel
        # and virtualbox-kernel-addons)
        SRCNAME=${SRCNAME%%$VERSION*}[0-9$VERSION]\*${SRCNAME##*$VERSION}
    fi

    ls -A $SRCDIR | grep "^${SRCNAME##*/}"
}

check_source() {
    # Check the source file for correctness.
    # Parameters:
    # - $1 = package name
    # - $2 = expected MD5
    # - $3 = source file name
    # Returns 0 if the source is OK, 1 if the source should be (re)downloaded
    # (this includes the cases where $3 is empty or refers to a nonexistent
    # file) and 2 if the user asked to abort the build.

    local PKG=$1
    local MD5SUM="$2"
    local SRCNAME="$3"
    local MD5CHK ANS

    # If there's no known source name, or if it doesn't exist, it has to be
    # downloaded...
    [[ -z $SRCNAME || ! -f $SRCDIR/$SRCNAME ]] && return 1

    # Check MD5
    echo "Checking MD5SUM for \"$SRCNAME\"..."
    MD5CHK=$(md5sum "$SRCDIR/$SRCNAME" | cut -d' ' -f1)
    if [[ $MD5CHK == $MD5SUM ]]; then
        echo "OK"
    else
        echo >> $TMPSUMMARYLOG
        echo "$PKG:" >> $TMPSUMMARYLOG
        echo "MD5SUM check failed." | tee -a $TMPSUMMARYLOG
        echo "Expected: $MD5SUM" | tee -a $TMPSUMMARYLOG
        echo "Found:    $MD5CHK" | tee -a $TMPSUMMARYLOG
        # Ask the user what to do with the bad source
        while :; do
            cat << EOF

Do you want to use the downloaded $PKG source:
$SRCNAME in $SRCDIR?

You can choose among the following options:
 - (Y)es, keep the source and continue;
 - (N)o, delete the source and abort build;
 - No, (d)ownload another copy and try again.
Your choice?
EOF
            error_read ANS
            case $ANS in
                n* | N* )
                    rm -f "$SRCDIR/$SRCNAME"
                    echo "Source deleted." | tee -a $TMPSUMMARYLOG
                    return 2
                    ;;
                y* | Y* )
                    MD5SUM=$(tr / _ <<< "$MD5CHK")
                    echo "Keeping the source and continuing." |
                        tee -a $TMPSUMMARYLOG
                    return 0
                    ;;
                d* | D* )
                    echo "Downloading again." | tee -a $TMPSUMMARYLOG
                    return 1
                    ;;
                * )
                    echo "Unknown response."
                    ;;
            esac
        done
    fi
}

get_source() {
    # Check to see if the source tarball exists in the local cache directory.
    # If it does, make a symlink to the package directory in the local mirror.
    # If it does not, download it and make the link.
    #
    # Parameters:
    # $1 = info file
    #
    # Return values:
    # 0 = all ok
    # 1 = failed, continue queue processing
    # 2 = failed, stop queue processing

    local INFO="$1"
    local PKG=$(sed 's:\.info.*$::g' <<< $INFO)
    local BUILD_LOCK=$SBOPKGTMP/sbopkg_build.lck
    local DLDIR=$SBOPKGTMP/sbopkg-download
    local PIDLIST=$SBOPKGTMP/sbopkgpidlist
    local TMPSUMMARYLOG=$SBOPKGTMP/sbopkg-tmp-summarylog
    local SRCNAME DL FAILURE ANS MD5CHK
    # Don't pollute the environment with the .info content...
    local PRGNAM VERSION HOMEPAGE DOWNLOAD MD5SUM MAINTAINER EMAIL APPROVED

    . "$INFO"
    SRCNAME=$(get_source_names "$INFO")

    while :; do
        check_source $PKG $MD5SUM $SRCNAME
        case $? in
            0 ) # Source OK
                break
                ;;
            2 ) # Abort
                FAILURE=download
                break
                ;;
        esac

        mkdir -p $DLDIR
        cd $DLDIR
        wget $WGETFLAGS $DOWNLOAD >> $SBOPKGOUTPUT & echo "$!" >> \
            $PIDLIST 2>> $SBOPKGOUTPUT
        wait
        # Source filename corrections for Virtualbox, where '?e=foo' gets
        # appended to the filename and for calcurse, where a 'foo?' gets
        # prepended to the filename
        DL=$(ls -A . 2> /dev/null)
        SRCNAME=$(sed 's/?e=.*$//;s/^.*?//' <<< "$DL")
        if [[ $SRCNAME ]]; then
            mv "$DL" "$SRCDIR/$SRCNAME"
        else
            FAILURE=download
            echo "$PKG:" >> $TMPSUMMARYLOG
            echo "Download failed." >> $TMPSUMMARYLOG
            echo >> $TMPSUMMARYLOG
        fi
        cd $SRCDIR
        rm -rf $DLDIR
        [[ $FAILURE ]] && break
    done

    cd $REPO_DIR/$PKGPATH
    rm -f "$SRCNAME"

    if [[ $FAILURE ]]; then
        rm -f $PKG.info.build
        rm -f $PKG.SlackBuild.build
        while :; do
            echo
            echo "Would you like to continue processing the rest of the"
            echo "build queue or would you like to abort?  If this failed"
            echo "package is a dependency of another package in the queue"
            echo "then it may not make sense to continue."
            echo
            echo "Press (Y)es to continue or (N)o to abort."
            error_read ANS
            case $ANS in
                y* | Y* ) return 1 ;;
                n* | N* ) rm -f $BUILD_LOCK && return 2 ;;
                * ) echo "Unknown response." ;;
            esac
        done
        return 2
    else
        ln -s "$SRCDIR/$SRCNAME" "$SRCNAME"
    fi
    return 0
}

remove_sources_for_app() {
    # Remove all sources from $SRCDIR for a particular application $1 is the
    # app's INFO file

    local INFO="$1"
    local APP_SOURCES=$SBOPKGTMP/sbopkg_app_sources
    local APP

    APP=${INFO##*/}
    APP=${APP%%.*}
    get_source_names --all "$INFO" | sed "s/^\(.*\)$/\"\\1\"/g" > $APP_SOURCES
    remove_sources "$APP" OFF
}

remove_obsoleted_sources() {
    # Remove all obsoleted sources

    local FIND_RESULT=$SBOPKGTMP/sbopkg_obsolete_find
    local SOURCES=$SBOPKGTMP/sbopkg_app_sources
    local PROGRESS=0
    local NUMINFO
    local INFO APP_CURRSRC REGEX

    { # Grouping for progressbar
    echo 0 # Progressbar begin

    find $REPO_DIR -name \*.info > $FIND_RESULT
    NUMINFO=$(wc -l < $FIND_RESULT)
    ls -A $SRCDIR > $SOURCES

    # Reading from $FIND_RESULT...
    while read INFO; do
        APP_CURRSRC=$(get_source_names "$INFO")
        if [[ $APP_CURRSRC ]]; then
            REGEX="/^$APP_CURRSRC$/d;$REGEX"
        fi

        # Progress indicator, for the progressbar
        (( PROGRESS += 1 ))
        echo $(($PROGRESS * 100 / $NUMINFO))
    done < $FIND_RESULT
    sed -i "$REGEX" $SOURCES
    } | progressbar "Searching obsolete sources" \
        "This may take a while, so please be patient..."

    # Quote file names
    sed -i "s/^\(.*\)$/\"\\1\"/" $SOURCES

    remove_sources "obsolete" ON
}

remove_sources() {
    # Remove all sources specified in $APP_SOURCES from $SRCDIR.
    # The source names _must_ be quoted.
    # $1 is the application name (used for display purposes only)
    # $2 is either "ON" or "OFF", and is used as the default checklist status

    local APP="$1"
    local ONOFF="$2"
    local APP_SOURCES=$SBOPKGTMP/sbopkg_app_sources
    local APP_SOURCES_CHECKLIST=$SBOPKGTMP/sbopkg_app_sources_checklist
    local APP_SOURCES_DELETING=$SBOPKGTMP/sbopkg_app_sources_deleting
    local SRC USER_OPTS DELETE ANS DLGWIDTH

    cd $SRCDIR
    if [[ -s $APP_SOURCES ]]; then
        sed "s/^\(.*\)$/\\1 \"\" $ONOFF/g" < $APP_SOURCES |
            sort > $APP_SOURCES_CHECKLIST
        if [[ $DIAG ]]; then
            # Compute a reasonable dialog width
            DLGWIDTH=$(wc -L < $APP_SOURCES_CHECKLIST)
            (( DLGWIDTH += 3 ))
            if [[ $DLGWIDTH -lt 50 ]]; then
                DLGWIDTH=50
            fi
            dialog --title "$(crunch "Displaying $APP sources")" \
                --ok-label "Keep all" --extra-label "Delete selected" \
                --cancel-label "OK" --no-cancel --extra-button \
                --separate-output --checklist "$(crunch "Would you like to \
                keep the $APP sources in the cache directory $SRCDIR?")"\
                20 $DLGWIDTH 12 \
                --file $APP_SOURCES_CHECKLIST 2> $APP_SOURCES_DELETING
            if [[ $? == 3 ]]; then
                DELETE=1
            fi
        else
            # Unquote file names
            tr -d \" < $APP_SOURCES > $APP_SOURCES_DELETING
            echo -e "[ Displaying $APP sources ]\n" |
                cat - $APP_SOURCES_DELETING | $PAGER
            while :; do
                echo
                echo "Do you want to delete these source files?"
                echo "Press (Y)es to delete or (N)o to keep them."
                read ANS
                case $ANS in
                    n* | N* ) break ;;
                    y* | Y* ) DELETE=1; break ;;
                    * ) echo "Unknown response." ;;
                esac
            done
        fi
        if [[ $DELETE && -s $APP_SOURCES_DELETING ]]; then
            # Reading from $APP_SOURCES_DELETING...
            while read SRC; do
                rm -f $SRCDIR/"$SRC"
            done < $APP_SOURCES_DELETING
            if [[ $DIAG ]]; then
                dialog --title "Done" --msgbox \
                    "$(crunch "The selected $APP sources have been \
                    cleared.")" 8 30
            else
                echo "$(crunch "The $APP sources have been cleared.")"
            fi
        fi
    else
        if [[ $DIAG ]]; then
            dialog --title "ERROR" --msgbox "$(crunch "It appears there are \
                no $APP sources in the cache directory.")" 8 30
        else
            echo "$(crunch "It appears there are no $APP sources in \
                the cache directory.")"
        fi
    fi
    rm -f $APP_SOURCES{,_CHECKLIST,_DELETING}
}

add_options() {
    # Adds pre-build options to SlackBuild

    local OPTIONPKG=$1
    local ADD_OPTIONS=$SBOPKGTMP/sbopkg_add_options
    local OPTIONFILE=$REPO_DIR/$CATEGORY/$APP/options.sbopkg
    local CUROPTIONS CHOICE CUSTOMOPTS

    if [[ ! -e $OPTIONFILE ]]; then
        unset CUROPTIONS
    else
        CUROPTIONS=$(< $OPTIONFILE)
    fi
    dialog --cancel-label "Clear Options" --inputbox \
        "$(crunch "Some SlackBuild scripts offer the ability to pass \
        variables, or options, or flavors to the SlackBuild scripts before \
        they are run.  This is often noted in the README or the SlackBuild \
        script itself.\n\nIf you would like to set \
        or edit these variables for the $1 SlackBuild, please enter that \
        information below, or press <Clear Options> to clear the options.")" \
        0 0 "$CUROPTIONS" 2> $ADD_OPTIONS
    CHOICE=$?
    CUSTOMOPTS="$(< $ADD_OPTIONS)"
    if [[ $CHOICE == 1 || ( $CHOICE == 0 && -z $CUSTOMOPTS ) ]]; then
        rm -f $OPTIONFILE
        continue
    elif [[ $CHOICE == 0 ]]; then
        cp $ADD_OPTIONS $OPTIONFILE
    fi
}

do_install() {
    # This is mostly equivalent to "upgradepkg --reinstall --install-new $@",
    # but also checks for renames

    local PKG PKGNAME
    local OLDPKG

    for PKG in "$@"; do
        # Strip the path from $PKG
        PKGNAME=${PKG##*/}
        # Remove version, arch, build and tag
        PKGNAME=$(sed 's/-[^-]*-[^-]*-[^-]*$//' <<< "$PKGNAME")

        get_old_name OLDPKG "$PKGNAME"
        upgradepkg --reinstall --install-new $OLDPKG%"$PKG"
    done
}

install_package() {
    # Install the package.

    local INSTDIR=$1
    local INSTPKG=$2
    local OWNER=$(stat -c %U $INSTDIR/$INSTPKG)
    local GROUP=$(stat -c %G $INSTDIR/$INSTPKG)

    if [[ $OWNER != root && $GROUP != root ]]; then
        crunch_fmt "WARNING:  The file $INSTPKG is not set with root:root \
            permissions!  Do you want to proceed?  Here is the \
            output of ls -l:"
        echo
        ls -l $INSTDIR/$INSTPKG
        echo
        echo "Press (Y)es to proceed or (N)o to abort."
        read ANS
        case $ANS in
            y* | Y* ) echo "Proceeding..." ;;
            n* | N* ) echo "Aborting..."; return 0 ;;
            * ) echo "Unknown response."; break ;;
        esac
    fi
    do_install $INSTDIR/$INSTPKG
    echo "Done upgrading/installing package."
}

error_read() {
    # This function wraps a simple 'read' call. The read itself is skipped if
    # $ON_ERROR != "ask", and the value put in the variable ($1) is "Yes" when
    # $ON_ERROR == "continue", and "No" when $ON_ERROR == "stop".
    # Useful in all those places where the CLI version of sbopkg asks the user
    # what to do on build errors.
    # The automatic answer is printed to stdout, to record it on the permanent
    # build log.

    case $ON_ERROR in
        ask) read $1; return ;;
        stop) eval $1=No; echo -n "No " ;;
        cont*) eval $1=Yes; echo -n "Yes " ;;
    esac
    echo "(as specified with '-e')"
}

build_package() {
    # This function fetches the source tarball and builds the package.
    # $1 = the package path
    # $2 = the package name
    # Returns:
    # 0 if the program built successfully, or if the user asked to ignore
    #   an error;
    # 1 in case of problems.
    # When processing a queue, the caller should continue processing the
    # queue items if build_package returns 0, and stop if it returns 1.

    local PKGPATH=$1
    local PKGNAME=$2

    echo
    echo "Building $PKGNAME"
    # Prepare a temporary output directory
    rm -rf $SB_OUTPUT
    mkdir -p $SB_OUTPUT

    # Fetch the source
    # Note that get_source() "knows" about the source cache, so this isn't
    # necessarily a download.
    cd $REPO_DIR/$PKGPATH
    get_source $PKGNAME.info.build
    case $? in
        0 ) ;;
        1 ) return 0 ;;
        * ) return 1 ;;
    esac

    # Start the actual build
    echo >> $TMPSUMMARYLOG
    echo "Building package for $PKGNAME..."
    (   # Run the build in a subshell, to avoid namespace pollution
        [[ $BUILDOPTIONS ]] && eval "export $BUILDOPTIONS"
        export OUTPUT=$SB_OUTPUT
        nice sh $PKGNAME.SlackBuild.build
    )

    # Cleanup
    cd $REPO_DIR/$PKGPATH
    rm $PKGNAME.{info,SlackBuild}.build

    # Let's see the result
    cd $SB_OUTPUT
    if [ ! -f *.t?z ]; then
        echo "$PKGNAME:" >> $TMPSUMMARYLOG
        echo "Error occurred with build.  Please check the log." \
            >> $TMPSUMMARYLOG
        echo
        echo "Would you like to continue processing the rest of the"
        echo "build queue or would you like to abort?  If this failed"
        echo "package is a dependency of another package in the queue"
        echo "then it may not make sense to continue."
        echo
        echo "Press (Y)es to continue or (N)o to abort."
        while :; do
            error_read ANS
            case $ANS in
                y* | Y* ) # Continue
                    return 0
                    ;;
                n* | N* ) # Abort
                    rm -f $SBOPKGTMP/sbopkg_build.lck
                    return 1
                    ;;
                * ) # Huh?
                    echo "Unknown response."
                    ;;
            esac
        done
    fi
}

edit_local_file() {
    # This function allows the user to create and edit a local copy of the
    # SlackBuild or of the info file.
    # $1 = info|SlackBuild (the extension of the customizable file)
    # $2 = application path
    # $3 = application name

    local FILE=$1
    local SHORTPATH=$2
    local APP=$3

    if [[ ! -e $SHORTPATH/$APP.$FILE.sbopkg ]]; then
        cp $SHORTPATH/$APP.$FILE $SHORTPATH/$APP.$FILE.sbopkg
    fi

    $EDITOR $SHORTPATH/$APP.$FILE.sbopkg
}

delete_local_file() {
    # This function allows the user to delete the local SlackBuild.
    # $1 = info|SlackBuild (the extension of the customizable file)
    # $2 = application path
    # $3 = application name

    local FILE=$1
    local SHORTPATH=$2
    local APP=$3

    # FIXME should be checked on the caller side?
    if [[ ! -e $SHORTPATH/$APP.$FILE.sbopkg ]]; then
        dialog --title "ERROR" --msgbox \
            "There is no local copy of the $FILE file to delete." 8 30
    else
        rm $SHORTPATH/$APP.$FILE.sbopkg
        dialog --title "DONE" --msgbox \
            "The local copy of the $FILE file has been deleted." 8 30
    fi
}

pick_file() {
    # This function checks to see if there is a locally-edited .info or
    # SlackBuild file (which has the *.sbopkg" suffix) and then asks the
    # user which one he wants to use to build a package.
    # The user can also choose to view a diff of the two before choosing
    # between them.
    # DIFF defines the diff program used and DIFFOPTS the diff options.
    # $1 = info|SlackBuild (the extension of the customizable file)
    # $2 = the package path
    # $3 = the package name
    # Returns 0 if the user did his choice, 1 if ESC was pressed.

    local FILE=$1
    local PKGPATH=$2
    local PKG=$3
    PICKFILE=original
    local ANS ITEM

    rm -f $SBOPKGTMP/sbopkg_file_selection $SBOPKGTMP/sbopkg_diff
    # FIXME slakmagik, what's going on here?
    # (this was added in r446)
    if (( ${#PKGPATH[*]} > 1 )); then
        select ITEM in ${PKGPATH[*]#*/} Quit; do
            if [[ $ITEM == Quit ]]; then
                exit
            fi
            PKGPATH=$ITEM
            if [[ -z $ITEM ]]; then
                echo "$SCRIPT: invalid choice."
                continue
            else
                break
            fi
        done
    fi

    # Build the diff, if there are 2 files to choose between
    if [[ -f $PKGPATH/$PKG.$FILE.sbopkg ]]; then
        $DIFF $DIFFOPTS $PKGPATH/$PKG.$FILE{,.sbopkg} \
            > $SBOPKGTMP/sbopkg_diff
    fi
    # Ask the user which file he wants sbopkg to use.
    if [[ -s $SBOPKGTMP/sbopkg_diff ]]; then
        if [[ $DIAG ]]; then
            while :; do
                dialog --title "Choose $PKG $FILE file" --menu \
                    "$(crunch "A local $FILE file for $PKG was found in \
                    addition to the original file. Which one \
                    would you like to use?")" 11 60 3 \
                    "Local" "Use the local $FILE" \
                    "Original" "Use the original $FILE" \
                    "Diff" "View a diff of the two" \
                    2> $SBOPKGTMP/sbopkg_file_selection

                ANS=$(< $SBOPKGTMP/sbopkg_file_selection)

                case $ANS in
                    Local )
                        PICKFILE="local"
                        break
                        ;;
                    Original )
                        PICKFILE="original"
                        break
                        ;;
                    Diff )
                        dialog --title "Viewing diff of $FILE file" \
                            --textbox $SBOPKGTMP/sbopkg_diff 0 0
                        ;;
                    *)  # The user pressed ESC
                        rm $SBOPKGTMP/sbopkg_diff
                        return 1
                        ;;
                esac
            done
        else
            while :; do
                echo
                crunch_fmt "A local $FILE file for $PKG was found in \
                    addition to the original $FILE file."
                echo "Which one would you like to use?"
                echo
                crunch_fmt "(O)riginal, (L)ocal, (D)iff, (C)ancel:"
                read ANS
                case $ANS in
                    o* | O* )
                        PICKFILE="original"
                        break
                        ;;
                    l* | L* )
                        PICKFILE="local"
                        break
                        ;;
                    d* | D* )
                        $PAGER $SBOPKGTMP/sbopkg_diff
                        ;;
                    c* | C* )
                        rm $SBOPKGTMP/sbopkg_diff
                        cleanup
                        return 1
                        ;;
                    * ) # Huh?
                        echo "Unknown response."
                        ;;
                esac
            done
        fi

        rm $SBOPKGTMP/sbopkg_diff
    fi

    if [[ $PICKFILE == original ]]; then
        cp $PKGPATH/$PKG.$FILE $PKGPATH/$PKG.$FILE.build
    elif [[ $PICKFILE == local ]]; then
        cp $PKGPATH/$PKG.$FILE.sbopkg $PKGPATH/$PKG.$FILE.build
    fi
    return 0
}

use_options() {
    # This functions checks whether the user supplied custom build options.
    # If this is the case, ask the user whether these options should be used.
    # $1 = package path
    # $2 = package name
    # The resulting build options are returned in $BUILDOPTIONS.

    local PKGPATH=$1
    local OPTAPP=$2
    local TMPOPTIONS

    # By default (i.e. no options.sbopkg file) there are no build options.
    unset BUILDOPTIONS
    if [[ -f $PKGPATH/options.sbopkg ]]; then
        TMPOPTIONS=$(< $PKGPATH/options.sbopkg)
        if [[ $DIAG ]]; then
            dialog --title "Use Options for $OPTAPP" --yesno \
                "$(crunch "Custom options for the $OPTAPP SlackBuild were \
                found:\n\n$TMPOPTIONS\n\nWould you like to use these options \
                for this build?")" 12 50
            if [[ $? == 0 ]]; then
                BUILDOPTIONS=$TMPOPTIONS
            fi
        else
            while :; do
                echo "Custom options for the $OPTAPP SlackBuild"
                echo "script were found:"
                echo
                echo $TMPOPTIONS
                echo
                echo "Would you like to use these options for this"
                echo "build?  Press (Y)es to use these options or"
                echo "(N)o to skip them."
                echo
                read ANS
                case $ANS in
                    y* | Y* )
                        BUILDOPTIONS=$TMPOPTIONS
                        break
                        ;;
                    n* | N* )
                        break
                        ;;
                    * )
                        echo "Unknown response."
                        ;;
                esac
            done
            echo
        fi
    fi
}

process_queue() {
    local QUEUETYPE=$1 # build|buildinstall

    # need to check the following before uncommenting
    #local PKG PKGBUILD SINGLE PKGPATH CHKBUILD ANS
    local CHKBUILD ANS COUNTER

    rm -f $TMPLOG $TMPBUILDLOG $TMPSUMMARYLOG $FINALQUEUE
    # Start the precheck
    echo >> $TMPLOG
    echo "++++++++++++++++++++++++++++++++++++++++++" >> $TMPLOG
    echo "       New queue process started on" >> $TMPLOG
    echo "       $(date)" >> $TMPLOG
    echo "++++++++++++++++++++++++++++++++++++++++++" >> $TMPLOG
    echo >> $TMPLOG
    echo "------------------------------------------" >> $TMPLOG
    echo "PACKAGE BUILDING/INSTALLATION PRECHECK LOG" >> $TMPLOG
    echo "Using the $REPO_DESC" >> $TMPLOG
    if [[ $QUEUETYPE == "buildinstall" ]]; then
        echo "Queue process: build and install" >> $TMPLOG
    else
        echo "Queue process: build" >> $TMPLOG
    fi
    echo >> $TMPLOG
    COUNTER=1
    for CHKBUILD in $(< $STARTQUEUE); do
        # FIXME: This section still needs to be reviewed
        unset PKG PKGPATH PKGNAME VERSION BUILD PICKFILE FILE
        echo "Package $COUNTER: $CHKBUILD" >> $TMPLOG
        if ! search_package $CHKBUILD; then
            echo "$CHKBUILD not found!" >> $TMPLOG
            echo >> $TMPLOG
            COUNTER=$((COUNTER+1))
            continue
        else
            echo $CHKBUILD >> $FINALQUEUE
        fi
        if ! pick_file info $PKGPATH $CHKBUILD; then
            rm -f $PKGPATH/$CHKBUILD*.build
            return 0
        else
            . $PKGPATH/$CHKBUILD.info.build
            echo "Using $PICKFILE .info file" >> $TMPLOG-files
        fi
        if ! pick_file SlackBuild $PKGPATH $CHKBUILD; then
            rm -f $PKGPATH/$CHKBUILD*.build
            return 0
        else
            BUILD=$(egrep -m1 "^BUILD" $PKGPATH/$CHKBUILD.SlackBuild.build |
                sed -e 's/^.*[=-]//;s/\"//;s/[ #}\t].*$//g;s/\"//g')
            echo "Using $PICKFILE SlackBuild file" >> $TMPLOG-files
        fi
        echo "Found $CHKBUILD $VERSION-$BUILD" >> $TMPLOG
        cat $TMPLOG-files >> $TMPLOG
        rm $TMPLOG-files
        use_options $PKGPATH $CHKBUILD
        if [[ $BUILDOPTIONS ]]; then
            echo "Options: $BUILDOPTIONS" >> $TMPLOG
        else
            echo "Options: None" >> $TMPLOG
        fi
        echo >> $TMPLOG
        COUNTER=$((COUNTER+1))
    done
    echo "------------------------------------------" >> $TMPLOG
    if [[ ! -e $FINALQUEUE ]]; then
        return 1
    fi
    if [[ $DIAG ]]; then
        dialog --title "Pre-Check Log" --ok-label "Start Build" \
            --extra-button --extra-label "Back" --no-cancel \
            --textbox $TMPLOG 0 0
        if [[ $? != 0 ]]; then
            return 0
        fi
    else
        while :; do
            cat $TMPLOG
            echo
            echo "Pre-check complete."
            echo
            crunch_fmt "Do you wish to proceed based on the search\
                results above? Packages not found will be skipped during\
                the process."
            echo
            echo "Press (Y)es to proceed or (N)o to quit."
            read ANS
            case $ANS in
                y* | Y* )
                    break
                    ;;
                n* | N* )
                    return 0
                    ;;
                * )
                    echo "Unknown response."
                    ;;
            esac
        done
        echo
    fi
    if [[ $KEEPLOG ]]; then
        cat $TMPLOG >> $LOGFILE
    fi
    rm $TMPLOG
    # Okay, precheck done, now start the actual queue processing (build or
    # build+install)
    > $SBOPKGTMP/sbopkg_build.lck
    COUNTER=1
    for PKGBUILD in $(< $FINALQUEUE); do
        if ! search_package $PKGBUILD; then
            echo "$PKGBUILD not found!" >> $TMPLOG
            continue
        fi
        if [[ -f $SBOPKGTMP/sbopkg_build.lck ]]; then
            build_package $PKGPATH $PKGBUILD 2>&1 | tee $TMPBUILDLOG ||
                break
            echo "Done building package for $PKGBUILD."
            cd $SB_OUTPUT
            NEWPACKAGE=$(ls -1t *.t?z | head -n1)
            echo "Package $COUNTER: $PKGBUILD" >> $TMPSUMMARYLOG
            echo "Built package: $NEWPACKAGE" >> $TMPSUMMARYLOG
            echo "Built package: $NEWPACKAGE"
            if [[ $QUEUETYPE == "buildinstall" ]]; then
                if [[ $SB_OUTPUT/*.t?z ]]; then
                    cd $SB_OUTPUT
                    NEWPACKAGE=$(ls -1t *.t?z | head -n1)
                    install_package $SB_OUTPUT $NEWPACKAGE
                    echo "Installed package: $NEWPACKAGE" >> $TMPSUMMARYLOG
                fi
            fi
            if [[ $SB_OUTPUT/*.t?z ]]; then
                mv $SB_OUTPUT/*.t?z $OUTPUT/
            fi
        else
            echo "$PKGBUILD:" >> $TMPSUMMARYLOG
            echo "Not processed - build queue aborted." >> $TMPSUMMARYLOG
            echo >> $TMPSUMMARYLOG
        fi
        COUNTER=$((COUNTER+1))
    done
    if [[ $KEEPLOG ]]; then
        cat $TMPBUILDLOG >> $LOGFILE
        rm $TMPBUILDLOG
    fi
    rm -f $SBOPKGTMP/sbopkg_build.lck
    echo >> $TMPLOG
    echo "------------------------------------------" >> $TMPLOG
    echo "PACKAGE BUILDING/INSTALLATION SUMMARY LOG" >> $TMPLOG
    echo "Using the $REPO_DESC" >> $TMPLOG
    if [[ $QUEUETYPE == "buildinstall" ]]; then
        echo "Queue process: build and install" >> $TMPLOG
    else
        echo "Queue process: build" >> $TMPLOG
    fi
    cat $TMPSUMMARYLOG >> $TMPLOG
    rm $TMPSUMMARYLOG
    echo >> $TMPLOG
    echo "------------------------------------------" >> $TMPLOG
    echo >> $TMPLOG
    echo "++++++++++++++++++++++++++++++++++++++++++" >> $TMPLOG
    echo "          Queue process complete" >> $TMPLOG
    echo "++++++++++++++++++++++++++++++++++++++++++" >> $TMPLOG
    echo >> $TMPLOG
    cat $TMPLOG
    read -n 1 -p "Press any key to continue."
    if [[ $KEEPLOG ]]; then
        cat $TMPLOG >> $LOGFILE
    fi
    rm $TMPLOG
    if [[ -f $TMPQUEUE ]]; then
        dialog --title "Clear Queue?" --yes-label "Keep" --no-label \
            "Clear" --yesno "$(crunch "Would you like to keep the build \
            queue or would you like to clear it?")" 8 35
        if [[ $? == 1 ]]; then
            rm $TMPQUEUE
            dialog --title "Done" --msgbox \
                "The build queue has been cleared." 8 35
        fi
    fi
    rm -f $SBOPKGTMP/sbopkg-ans-queue
    rm -f $FINALQUEUE
}

start_dialog_queue() {
    # This kick-starts the queue processing when using the dialog interface.
    # When using cli, the -b or -i option will determine whether we build or
    # build and install.

    dialog --title "Install Package(s)" --yesno \
        "$(crunch  "Would you like to install the packages as they are \
            built?  Press <Yes> to install, <No> to build only, or <Esc> \
            to exit.")" 8 50
    case $? in
        255|-1 ) # The user pressed ESC
            return 0
            ;;
        0 ) # Build and install
            process_queue buildinstall
            if [[ $? == 1 ]]; then
                dialog --title "Error" --msgbox "$(crunch "No valid \
                    packages found.")" 8 40
            fi
            ;;
        1 ) # Build only
            process_queue build
            if [[ $? == 1 ]]; then
                dialog --title "Error" --msgbox "$(crunch "No valid \
                    packages found.")" 8 40
            fi
            ;;
    esac
}

check_for_latest() {
    # Check for an update to sbopkg.  This code is borrowed with
    # permission from the superb mirror-slackware-current.sh
    # by Eric Hameleers which you can find at
    # http://www.slackware.com/~alien.  Thanks, Eric!

    local ORIGSCR=http://www.sbopkg.org/version.php
    local CVRS=$SBOVER
    local NVRS=$(wget -T 10 -q -O - $ORIGSCR)
    local NEWPKG=http://www.sbopkg.org/pkg.php
    local NEWSBOPKG=$(wget -T 10 -q -O - $NEWPKG)
    # FIXME do we really want a googlecode reference here?
    # I suggest a new pkg2.php containing the full download path, or to set up
    # a sbopkg.org link bouncing to googlecode.
    local NEWDLPKG=http://sbopkg.googlecode.com/files/$NEWSBOPKG
    local SBOPKGUP MSG ANS

    if [[ -z $CVRS || -z $NVRS ]]; then
        if [[ -z $NVRS ]]; then
            MSG="Cannot determine if there is an update \
                since the remote version cannot be retrieved. \
                Please try again later."
        fi
    elif [[ $CVRS != $NVRS ]]; then
        if grep -q svn_r <<< $CVRS; then
            MSG="You are running sbopkg from SVN and not using a regular \
                package.  Therefore, package versions cannot be compared."
        else
            SBOPKGUP=1
            if [[ $DIAG ]]; then
                MSG="Different versions reported.  Press <OK> to continue."
            else
                MSG="Different versions reported.  Press (Y)es to \
                    download the update package or press (N)o to quit."
            fi
        fi
    else
        MSG="It appears your version of sbopkg is up to date."
    fi
    if [[ $DIAG ]]; then
        dialog --title "Done" --msgbox "$(crunch "Checking \
            http://www.sbopkg.org for an update...\n\nYour version of \
            sbopkg: $CVRS\n\nLatest version of sbopkg found on \
            sbopkg.org: $NVRS\n\n$MSG")" 16 40
        if [[ $? != 0 ]]; then
            return 0
        fi
        if [[ $SBOPKGUP ]]; then
            dialog --title "Download new package?" --yesno "$(crunch "Would \
                you like to download the new sbopkg \
                package:\n\n$NEWSBOPKG\n\nThe new sbopkg package will saved \
                to your OUTPUT directory: $OUTPUT")" 13 50
            if [[ $? != 0 ]]; then
                return 0
            fi
        fi
    else
        echo
        echo "Checking http://www.sbopkg.org for an update..."
        echo
        echo "Your version of sbopkg: $CVRS"
        echo
        echo "Latest version of sbopkg found on sbopkg.org: $NVRS"
        echo
        crunch_fmt "$MSG"
        if [[ $SBOPKGUP ]]; then
            while :; do
                read ANS
                case $ANS in
                    y* | Y* ) break ;;
                    n* | N* ) return 0 ;;
                    * ) echo "Unknown response." ;;
                esac
            done
        fi
    fi
    if [[ $SBOPKGUP ]]; then
        cd $OUTPUT
        wget $WGETFLAGS $NEWDLPKG
        cd "$CWD"
        crunch_fmt \
            "######################################################\
            \nDownload complete. The downloaded file is located at:\
            \n\
            \n$OUTPUT/$NEWSBOPKG\
            \n\
            \nYou can now quit sbopkg and upgrade sbopkg manually.\
            \n\
            \nOnce you have upgraded sbopkg, please be sure to check \
            the /etc/sbopkg/sbopkg.conf.new file for any changes that may \
            need to be merged into your existing /etc/sbopkg/sbopkg.conf \
            file.\
            \n\
            \nYou can also view a complete ChangeLog.txt in the\
            /usr/share/doc/sbopkg-$NVRS/ directory or online at:\
            \nhttp://www.sbopkg.org/files/ChangeLog.txt\
            \n"
        if [[ $DIAG ]]; then
            read -n 1 -p "Press any key to continue."
        fi
    fi
}

queue_menu() {
    # Separate menu for queue functions.

    local DEFAULTITEM
    local ANSWERFILE=$SBOPKGTMP/sbopkg_queue_menu_answer

    while :; do
        dialog --title "Build Queue Menu" --backtitle \
            "Currently using the $REPO_DESC." \
            --cancel-label "Back" --default-item "$DEFAULTITEM" --menu \
            "\nChoose one of the following or press <Back> to go back.\n" \
            15 60 7 \
            "View" "View the current build queue" \
            "Load" "Load a saved build queue" \
            "Save" "Save the current build queue" \
            "Edit" "Edit the current build queue" \
            "Rename" "Rename a saved build queue" \
            "Delete" "Delete a saved build queue" \
            "Process" "Process the current build queue" 2> $ANSWERFILE

        DEFAULTITEM=$(< $ANSWERFILE)

        case "$DEFAULTITEM" in
            "View") #empty_queue && return
                    view_queue ;;
            "Load") load_user_queue ;;
            "Save") save_user_queue ;;
            "Edit") edit_build_queue ;;
            "Rename") rename_user_queue ;;
            "Delete") delete_user_queue ;;
            "Process") #empty_queue && continue
                       view_queue || continue
                       cp $SBOPKGTMP/sbopkg-ans-queue $STARTQUEUE
                       start_dialog_queue  ;;
            *) break ;;
        esac
    done

    rm -f $ANSWERFILE
}

utilities_menu() {
    # Separate menu for various utilities.

    local DEFAULTITEM;
    local ANSWERFILE=$SBOPKGTMP/sbopkg_utilities_menu_answer

    while :; do
        dialog --title "Utilities Menu" --backtitle \
            "Currently using the $REPO_DESC." \
            --cancel-label "Back" --default-item "$DEFAULTITEM" --menu \
            "\nChoose one of the following or press <Back> to go back.\n" \
            15 69 5 \
            "Cache" "View the contents of the cache directory" \
            "Log" "View the permanent build log" \
            "Repository" "Select repository [ $REPO_BRANCH ($REPO_NAME) ]" \
            "Latest" "Check for an update to sbopkg"  \
            "Obsolete" "View the obsoleted cached sources" 2> $ANSWERFILE

        DEFAULTITEM=$(< $ANSWERFILE)

        case "$DEFAULTITEM" in
            "Cache" ) view_cache_dir ;;
            "Log" ) view_perm_log ;;
            "Repository" ) select_repository ;;
            "Latest" ) check_for_latest ;;
            "Obsolete" ) remove_obsoleted_sources ;;
            *) break ;;
        esac
    done

    rm -f $ANSWERFILE
}

cleanup() {
    # Clean up cruft and remove temporary files.

    if [[ $HAS_NCURSES ]]; then
        tput cnorm # Restore cursor
    fi
    rm -f $SBOPKGTMP/sbopkg_*
    rm -f $SBOPKGTMP/sbopkgpidlist
    rm -rf $SBOPKGTMP/sbopkg-sbooutputdir
    rm -f $SBOPKGTMP/sbopkg-*-queue
    rm -f $SBOPKGTMP/sbopkg-tmp-*
    rm -f $PIDFILE

    # Back to the directory the user started sbopkg in
    cd "$CWD"
}

control_c() {
    # This function holds the commands that will be executed when the user
    # presses Control-C.  The $SBOPKGTMP/sbopkgpidlist file is the file to
    # which various PID's are written to as certain background processes etc.
    # are executed.

    local PID
    local SBOPKG_PIDLIST=$SBOPKGTMP/sbopkgpidlist

    echo
    echo "Control-C detected.  Trying to exit cleanly...";
    if [[ -f $SBOPKG_PIDLIST ]]; then
        for PID in $(< $SBOPKG_PIDLIST); do
            echo "killing $PID"
            kill -9 $PID;
        done;
        rm $SBOPKG_PIDLIST
    fi
    if [[ ! $DIAG ]]; then
        cleanup
        exit 0
    fi
}

main_search() {
    # This is the main package search gateway, showing the search box dialog
    # and calling the appropriate search function after validating the user
    # input.

    local TERM_FILE=$SBOPKGTMP/sbopkg_search_request
    local PKG STRING SEARCH_TERM
    local REPO=$REPO_DIR

    check_if_repo_exists
    while :; do
        unset PKG STRING

        dialog --title "Search" --ok-label "PKG" \
            --extra-button --extra-label "String" \
            --help-button --inputbox \
            "Enter your search term (prefix your string search with 'inst:' \
                to narrow search to installed packages)..." 11 41 \
                2> $TERM_FILE
        case $? in # 0=PKG 3=String 1=Cancel 2=Help
            3 ) # String search
                STRING=yes ;;
            2 ) # Help
                dialog --title "Search Help" --msgbox \
                    "$(crunch "This widget provides the choice of a package \
                    <PKG> search or a string <String> search.\n\nThe package \
                    search executes a glob search on package names in \
                    $REPO.\n\nThe string search executes 'grep -iwm1 \
                    \"your_string\"' on the README files in the repo. This \
                    means it returns the first matching line from the README \
                    files, where the line contains a case-insensitive word \
                    that matches your string, where a 'word' is a sequence of\
                    alphanumeric characters and underscores. For details, see\
                    the egrep(1) manual page.\n\nIf the search string is \
                    prefixed with \"inst:\" in the form \"inst:your_string\",\
                    then it will search for \"your_string\" within installed \
                    packages only.")" 0 0
                continue
                ;;
            0 ) # Package search
                PKG=yes ;;
            * ) # Cancel or ESC
                break ;;
        esac

        if [[ -s $TERM_FILE ]]; then
            SEARCH_TERM=$(< $TERM_FILE)
            # I can't make sure every input makes sense, but I can at least
            # clear out this area of (fairly improbable) glitches
            if [[ $SEARCH_TERM =~ "^[\\\.\*\^\$\[\{\(\)\+\?\|]$" ]]; then
                dialog --msgbox "$(crunch "If you are searching for the \
                    literal character '$SEARCH_TERM', then you will need to \
                    escape it with a backslash like '\\\\$SEARCH_TERM'.\n\nIf\
                    you are still not getting the expected results, remember \
                    that string searches perform a word match -\
                    try adding '.*'")" 0 0
                continue
            fi
        else
            break
        fi

        if [[ $PKG ]]; then
            gen_search_package "$SEARCH_TERM" || break
        elif [[ $STRING ]]; then
            string_search "$SEARCH_TERM" || break
        fi
    done

    rm -f $TERM_FILE
    return 0
}

main_updates() {
    # This is the dialog gateway for the updates code. Mainly, it runs the
    # updates check and optionally queues the updated packages.

    local APP VERSIONBUILD ONOFF PICK
    local UPDATES_QUEUE=$SBOPKGTMP/sbopkg-update-queue

    rm -f $UPDATES_QUEUE
    check_for_updates
    if [[ -f $UPDATES_QUEUE ]]; then
        dialog --title "Add Updates to Queue?" --yesno \
            "$(crunch "Would you like to add the flagged updates to \
            the build queue?")" 8 35
        if [[ $? == 0 ]]; then
            # Reading from $UPDATES_QUEUE...
            while read PICK; do
                eval $(sed "s/^\(.*\) \(.*\) \(.*\)\$/\
                    APP=\\1 VERSIONBUILD=\\2 ONOFF=\\3/g" <<< $PICK)
                add_item_to_queue $APP $VERSIONBUILD $ONOFF
            done < $UPDATES_QUEUE
            rm -f $UPDATES_QUEUE
            dialog --title "Done" --msgbox "$(crunch "The flagged \
                updates have been added to the build queue.")" 8 30
        fi
    fi
}

main_menu() {
    # This is the main dialog menu.

    local DEFAULTITEM
    local ANSWER_FILE=$SBOPKGTMP/sbopkg_main_menu_answer

    while :; do
        dialog --cancel-label "Exit" --default-item "$DEFAULTITEM" --title \
            "SlackBuilds.org Package Browser (sbopkg version $SBOVER)" \
            --backtitle \
            "Currently using the $REPO_DESC." \
            --menu \
            "\nChoose one of the following or press <Exit> to exit.\n" \
            17 69 8 \
            "Sync" "Sync with the remote repository" \
            "ChangeLog" "View the ChangeLog" \
            "Packages" "List installed $REPO_NAME packages" \
            "Updates" "List potential updates to installed $REPO_NAME packages" \
            "Browse" "Browse the active repository" \
            "Search" "Search the active repository" \
            "Queue" "Manage the build queue" \
            "Utilities" "Go to the utilities menu" 2> $ANSWER_FILE

        DEFAULTITEM=$(< $ANSWER_FILE)

        case "$DEFAULTITEM" in
            "Sync" )
                sync_repo ;;
            "ChangeLog" )
                show_changelog ;;
            "Packages" )
                get_sbo_packages ;;
            "Updates" )
                main_updates ;;
            "Browse" )
                browse_categories ;;
            "Search" )
                main_search ;;
            "Utilities" )
                utilities_menu ;;
            "Queue" )
                queue_menu ;;
            * ) # Exit or ESC
                save_user_queue --end
                clear
                return 0
                ;;
        esac
    done
}

# END OF FUNCTIONS.  What comes below is the actual start of the
# script when it is first run.

# Global variables
# There are two groups of global variables:
# - those that are meant to be global;
# - those that are global only because they are used in this part of the
#   script
# The second group should be reduced/removed. For now, they are simply listed
# here in a group, instead of being commented one by one.
unset SCRIPT          # The script name (usually "sbopkg")
unset REV             # Revision number
unset SBOVER          # The sbopkg version
unset CWD             # sbopkg starting directory
unset DIAG            # When set, run in dialog mode (instead of CLI mode)
unset QUIET           # When set, suppress less important output in CLI mode
unset ON_ERROR        # The policy used in error conditions (see "-e")
unset LAST_USER_QUEUE_ON_DISK # The name of the last loaded/saved user queue
unset BUILDOPTIONS    # TODO
#     SBOPKG_RENAMES_D  # Directory containing files tracking package renames
#     SBOPKG_REPOS_D  # Directory containing repositories definitions
#     SBOPKG_CONF     # Configuration file
#     REPO_ROOT       # Directory containing all repository mirrors
unset HAS_NCURSES     # Set if the ncurses package is installed
unset REPO_NAME       # Currently active repository (e.g. SBo)
unset REPO_BRANCH     # Currently active branch (e.g. 12.2)
unset REPO_DESC       # Active branch's description
unset REPO_TAG        # Active branch's packages' tag
unset REPO_TOOL       # Active branch's fetch tool
unset REPO_LINK       # Active branch's fetch link
unset REPO_DIR        # Active branch's directory

unset BUILD BFLAG IFLAG CHK_UPDATES GENSEARCH CHANGELOG OBSOLETESRC GETPKGS
unset RSYNC SEARCH UPDATE VERSION CUSTOMVER

SCRIPT=${0##*/}
SBOPKG_CONF=${SBOPKG_CONF:-/etc/sbopkg/sbopkg.conf}
SBOPKG_RENAMES_D=${SBOPKG_RENAMES_D:-/etc/sbopkg/renames.d}
SBOPKG_REPOS_D=${SBOPKG_REPOS_D:-/etc/sbopkg/repos.d}
EDITOR=${EDITOR:-vi}
PAGER=${PAGER:-more}
CWD=$(pwd)
REV="$Revision$"
SBOVER=svn_r$(cut -d' ' -f2 <<< "$REV")
DIAG=1
ON_ERROR=ask

# Make sure we are root.
if [[ $(id -u) != 0 ]]; then
    echo "$SCRIPT: $SCRIPT must be run by the root user.  Exiting." >&2
    exit 1
fi

# This is the command line options and help.
while getopts ":b:cd:e:f:g:hi:lopqrs:uv:" OPT; do
    case $OPT in
        b ) # Build
            BFLAG=1
            TYPE="build"
            BUILD="$OPTARG"
            unset DIAG
            ;;
        c ) # Check for updates to installed SBo packages
            CHK_UPDATES=1
            unset DIAG
            ;;
        d ) # Location of the local SBo repository
            REPO_ROOT=$OPTARG
            ;;
        e ) # Default on-error behavior
            ON_ERROR=$OPTARG
            unset DIAG
            ;;
        f ) # Location of the configuration file
            SBOPKG_CONF=$OPTARG
            ;;
        g ) # String search
            GENSEARCH="$OPTARG"
            unset DIAG
            ;;
        i ) # Build and install
            IFLAG=1
            TYPE="buildinstall"
            BUILD="$OPTARG"
            unset DIAG
            ;;
        l ) # Show SBo ChangeLog
            CHANGELOG=1
            unset DIAG
            ;;
        o ) # Show obsoleted sources
            OBSOLETESRC=1
            unset DIAG
            ;;
        p ) # List installed SBo packages
            GETPKGS=1
            unset DIAG
            ;;
        q ) # Quiet mode
            QUIET=1
            unset DIAG
            ;;
        r ) # sync with the remote repository
            SYNC=1
            unset DIAG
            ;;
        s ) # Name search
            SEARCH="$OPTARG"
            unset DIAG
            ;;
        u ) # Search an updated sbopkg package
            UPDATE=1
            unset DIAG
            ;;
        v ) # Set repository
            VERSION=1
            CUSTOMVER="$OPTARG"
            ;;
        h | * ) # Help
            cat << EOF
$SCRIPT $SBOVER
Usage: $SCRIPT [OPTIONS] <packagename(s)>
Options are:
  -b pkg/queue(s) Build the specified package(s). If one or more queues are
                  specified, build the packages they refer to.
  -c              Check for updates to installed packages.
  -d localdir     Location of local copy of the repositories.
  -e error_action Specify what sbopkg is supposed to do on build errors.
                  Valid options are: ask (default), continue, stop.
  -f file         Override default configuration file with specified file.
  -g package(s)   General search for packages matching string.
  -h              Display this help message.
  -i pkg/queue(s) Like '-b', but also install built packages.
  -l              Display the repo's ChangeLog.txt and then quit.
  -o              Display the obsoleted source files and prompt for deletion.
  -p              List installed repo's packages.
  -q              Quiet some of the command-line output.
  -r              Sync the remote repository with the local mirror and then
                  quit.
  -s package(s)   Specific search by specific package and, if found,
                  display package information.
  -u              Check for an update to sbopkg.
  -v repo/branch  Set the repository/branch (e.g. "-v SBo/12.2").
                  If the repository name is not specified, sbopkg will first
                  try with the default one. If no match is found, sbopkg will
                  look for the first matching branch of any repository.
                  The default valid choices are SBo/{11.0,12.0,12.1,12.2} for
                  the SlackBuilds.org repository, SB64/master for the
                  builds.Slamd64.com repository and local/local for the local
                  repository).

Note: multiple arguments to -b, -g, -i, and -s must be quoted ("pkg1 pkg2")
EOF
            exit
            ;;
    esac
done

# End of option parsing.
shift $(($OPTIND - 1))
if [[ $# -gt 0 ]]; then
    echo "Error: unknown token \"$@\"" >&2
    exit 1
fi

if [[ $BFLAG && $IFLAG ]]; then
    echo "Error:  The -b and -i options cannot be used together." >&2
    echo "Please use one or the other.  Exiting." >&2
    exit 1
fi

if [[ $ON_ERROR != ask && \
      $ON_ERROR != continue && \
      $ON_ERROR != stop ]]; then
    echo "Unknown -e specifier -- \"$ON_ERROR\"" >&2
    echo "Valid values are: ask (default), continue, stop" >&2
    exit 1
fi

# Check for a good config file and set initial variables
config_check
STARTQUEUE=$SBOPKGTMP/sbopkg-start-queue
TMPLOG=$SBOPKGTMP/sbopkg_tmplog
TMPQUEUE=$SBOPKGTMP/sbopkg-tmp-queue
FINALQUEUE=$SBOPKGTMP/sbopkg-final-queue
SB_OUTPUT=$SBOPKGTMP/sbopkg-sbooutputdir
SBOPKGOUTPUT=$SBOPKGTMP/sbopkg_output
TMPBUILDLOG=$SBOPKGTMP/sbopkg-tmp-buildlog
TMPSUMMARYLOG=$SBOPKGTMP/sbopkg-tmp-summarylog

# Change $REPO_BRANCH (and optinally REPO_NAME) if set manually using cli -v
if [[ $VERSION ]]; then
    if [[ $CUSTOMVER =~ '.*/.*' ]]; then
        # The user specified repository/branch
        eval $(sed 's:^\(.*\)/\(.*\)$:REPO_NAME=\1;REPO_BRANCH=\2:g' \
            <<< $CUSTOMVER)
    else
        # The user specified only the branch -- keep the default repository
        REPO_BRANCH=$CUSTOMVER
        if ! set_repo_vars; then
            # Repository/branch not found -- let's try to be less strict.
            # Try again without enforcing REPO_NAME
            unset REPO_NAME
        fi
    fi
fi
set_repo_vars
if [[ $? -ne 0 ]] ; then
    echo "Unknown repository name -- \"$CUSTOMVER\"" >&2
    echo "Valid options are:" >&2
    for ((i=0; i<${#REPOSITORIES[@]}; i+=6)); do
        echo -en "${REPOSITORIES[$i]}/${REPOSITORIES[(($i + 1))]}\\t" >&2
        echo "(${REPOSITORIES[(($i + 2))]})" >&2
    done
    exit 1
fi

# Check for required directories
directory_checks

# Check for another instance
pid_check

if [[ $DIAG ]]; then
    if [[ $TERM =~ "^rxvt.*" || $TERM =~ "^screen.*" ]]; then
        dialog_refresh_workaround
    fi
    main_menu
    cleanup
else
    if [[ $BUILD ]]; then
        CLIQUEUE=$SBOPKGTMP/sbopkg_cli_queue
        > $SBOPKGTMP/sbopkg-start-queue
        for PKGBUILD in $BUILD; do
            if [[ -r $QUEUEDIR/$PKGBUILD.sboq ]] && search_package $PKGBUILD; then
                crunch_fmt "Both a queuefile and a package were found with \
                    the name \"$PKGBUILD\".  Which would you like to use?"
                echo
                echo "Please enter (Q)ueuefile, (P)ackage, or (A)bort:"
                while :; do
                    read ANS
                    case $ANS in
                        q* | Q* ) cp $QUEUEDIR/$PKGBUILD.sboq $CLIQUEUE
                                  break
                                  ;;
                        p* | P* ) echo $PKGBUILD >> $CLIQUEUE
                                  break
                                  ;;
                        a* | A* ) cleanup
                                  exit 1
                                  ;;
                        * ) echo "Unknown response." ;;
                    esac
                done
            else
                if [[ -r $QUEUEDIR/$PKGBUILD.sboq ]]; then
                    # Add an entire queue
                    cat $QUEUEDIR/$PKGBUILD.sboq >> $CLIQUEUE
                else
                    if search_package $PKGBUILD; then
                        # Add a single package
                        echo $PKGBUILD >> $CLIQUEUE
                    else
                        crunch_fmt "Queuefile or package $PKGBUILD not found - \
                            skipping."
                        echo
                    fi
                fi
            fi
        done
        if [[ ! -e $CLIQUEUE ]]; then
            echo "No valid queuefile or package name given.  Exiting."
            cleanup
            exit 1
        fi
        # Reading from $CLIQUEUE...
        while read PICK; do
            if can_skip_line $PICK; then
                continue
            fi
            PICK_NAME=${PICK%% *}
            if [[ ${PICK_NAME:0:1} == "-" ]]; then
                continue
            else
                if ! grep -qx $PICK_NAME $SBOPKGTMP/sbopkg-start-queue; then
                    echo $PICK_NAME >> $SBOPKGTMP/sbopkg-start-queue
                fi
            fi
        done < $CLIQUEUE
        rm -f $CLIQUEUE
        unset CLIQUEUE
        process_queue $TYPE
        if [[ $? == 1 ]]; then
            echo "No valid packages found.  Exiting."
            exit 1
        fi
    fi

    if [[ $CHK_UPDATES ]]; then
        check_for_updates
    fi

    if [[ $CHANGELOG ]]; then
        show_changelog
    fi

    if [[ $OBSOLETESRC ]]; then
        remove_obsoleted_sources
    fi

    if [[ $GETPKGS ]]; then
        get_sbo_packages
    fi

    if [[ $SYNC ]]; then
        crunch_fmt "Syncing with the remote repository into $REPO_DIR."
        sync_repo
        echo "Finished sync."
    fi

    if [[ -n $SEARCH ]]; then
        check_if_repo_exists
        for PKGSEARCH in "$SEARCH"; do
            echo "Searching for $PKGSEARCH"
            if search_package $PKGSEARCH; then
                pick_file info $PKGPATH $PKGSEARCH
                show_readme $PKGPATH $PKGSEARCH
            else
                echo "ERROR: Package \"$PKGSEARCH\" not found." >&2
            fi
        done
    fi

    if [[ $UPDATE ]]; then
        check_for_latest
    fi

    if [[ -n $GENSEARCH ]]; then
        check_if_repo_exists
        for PKGSEARCH in $GENSEARCH; do
            echo "Searching for $PKGSEARCH"
            gen_search_package $PKGSEARCH
        done
    fi

    cleanup
    echo
    echo "All done."
fi

exit 0

# vim:set syn=sh sw=4 et ts=4 tw=78:
# kate: syntax Bash; indent-width 4; replace-trailing-space-save on;
# kate: replace-tabs on; tab-width 4; word-wrap-column 78
